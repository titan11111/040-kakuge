<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>ã‚¹ãƒ†ã‚£ãƒƒã‚¯ãƒãƒ³æ ¼é—˜ã‚²ãƒ¼ãƒ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
            overscroll-behavior: none;
        }
        
        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #2a4858 0%, #4a6878 50%, #3a3a3a 100%);
            max-width: 100vw;
            max-height: 100vh;
            margin: 0 auto;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            color: white;
            z-index: 10;
            pointer-events: none;
        }
        
        .health-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .player-info-left,
        .player-info-right {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            min-width: 150px;
        }
        
        .player-info-right {
            align-items: flex-end;
        }
        
        .health-bar-wrapper {
            flex: 1;
            margin: 0 20px;
        }
        
        .health-bar {
            width: 100%;
            height: 30px;
            background: rgba(100, 0, 0, 0.8);
            border: 3px solid #fff;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            margin-bottom: 5px;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ff6b00, #00ff00);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        .guard-bar-wrapper {
            width: 100%;
        }
        
        .guard-bar {
            width: 100%;
            height: 8px;
            background: rgba(50, 50, 50, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }
        
        .guard-fill {
            height: 100%;
            background: linear-gradient(to right, #00ffff, #0088ff);
            transition: width 0.2s ease;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }
        
        .player-name {
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .player1-name {
            text-align: left;
        }
        
        .player2-name {
            text-align: right;
        }
        
        .combo-display {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px rgba(255, 215, 0, 0.8);
            margin-top: 5px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .combo-display.active {
            opacity: 1;
        }
        
        #timer {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
        }
        
        .mobile-controls {
            display: none;
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 15px;
            pointer-events: auto;
            z-index: 100;
        }
        
        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .dpad-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            width: 90px;
            height: 90px;
            position: relative;
        }
        
        .dpad-btn {
            grid-column: span 1;
            grid-row: span 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            user-select: none;
            transition: all 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .dpad-btn.empty {
            background: transparent;
            border: none;
            box-shadow: none;
            pointer-events: none;
        }
        
        .dpad-btn.up { grid-column: 2; grid-row: 1; }
        .dpad-btn.left { grid-column: 1; grid-row: 2; }
        .dpad-btn.down { grid-column: 2; grid-row: 3; }
        .dpad-btn.right { grid-column: 3; grid-row: 2; }
        
        .dpad-btn:active,
        .dpad-btn.touching {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.9);
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .btn-row {
            display: flex;
            gap: 8px;
        }
        
        .control-btn {
            width: 55px;
            height: 55px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            color: white;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            transition: all 0.1s ease;
            position: relative;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            text-align: center;
            line-height: 1.2;
        }
        
        .control-btn:active,
        .control-btn.touching {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.9);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }
        
        .restart-btn {
            padding: 15px 30px;
            font-size: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }
        
        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        
        .restart-btn:active {
            transform: translateY(0);
        }
        
        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 3px solid #fff;
            pointer-events: auto;
        }
        
        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }
        
        #gameOver p {
            font-size: 24px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
            
            #controls .restart-btn {
                display: none;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 10px;
            }
            
            .dpad-container {
                width: 80px;
                height: 80px;
            }
            
            .dpad-btn {
                font-size: 16px;
            }
            
            #ui {
                padding: 12px;
            }
            
            .player-name {
                font-size: 16px;
            }
            
            #timer {
                font-size: 32px;
                top: 45px;
            }
            
            .health-bar {
                height: 22px;
            }
            
            .combo-display {
                font-size: 18px;
            }
        }
        
        /* iOSå‘ã‘ã®ç‰¹åˆ¥ãªã‚¹ã‚¿ã‚¤ãƒ« */
        @media (max-width: 768px) and (-webkit-min-device-pixel-ratio: 2) {
            .control-btn {
                width: 52px;
                height: 52px;
                font-size: 11px;
            }
            
            .dpad-container {
                width: 85px;
                height: 85px;
            }
            
            .mobile-controls {
                padding: 0 12px;
                bottom: 12px;
            }
        }
        
        /* å°ã•ã„ç”»é¢å‘ã‘ */
        @media (max-width: 480px) {
            .control-btn {
                width: 48px;
                height: 48px;
                font-size: 9px;
            }
            
            .dpad-container {
                width: 75px;
                height: 75px;
            }
            
            .dpad-btn {
                font-size: 14px;
            }
            
            .btn-row {
                gap: 6px;
            }
            
            .action-buttons {
                gap: 6px;
            }
            
            .mobile-controls {
                padding: 0 10px;
                bottom: 10px;
            }
            
            #ui {
                padding: 8px;
            }
            
            .player-name {
                font-size: 14px;
            }
            
            #timer {
                font-size: 28px;
            }
        }
        
        /* æ¨ªå‘ãï¼ˆãƒ©ãƒ³ãƒ‰ã‚¹ã‚±ãƒ¼ãƒ—ï¼‰å‘ã‘ */
        @media (max-height: 500px) and (orientation: landscape) {
            .mobile-controls {
                bottom: 8px;
                padding: 0 10px;
            }
            
            .control-btn {
                width: 45px;
                height: 45px;
                font-size: 9px;
            }
            
            .dpad-container {
                width: 70px;
                height: 70px;
            }
            
            .dpad-btn {
                font-size: 13px;
            }
            
            #ui {
                padding: 8px;
            }
            
            .health-bar {
                height: 18px;
            }
            
            .player-name {
                font-size: 14px;
            }
            
            #timer {
                font-size: 24px;
                top: 35px;
            }
        }
        
        #characterSelect {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            z-index: 100;
            pointer-events: auto;
            padding: 20px;
        }
        
        .select-container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }
        
        #characterSelect h1 {
            font-size: 48px;
            color: #fff;
            text-align: center;
            margin: 20px 0 10px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            font-weight: bold;
        }
        
        #characterSelect h2 {
            font-size: 28px;
            color: white;
            margin: 30px 0 15px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .player-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .player-section h3 {
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .character-card {
            padding: 20px;
            background: rgba(255, 255, 255, 0.08);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            color: white;
            backdrop-filter: blur(10px);
        }
        
        .character-card:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: #ffd700;
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(255, 215, 0, 0.3);
        }
        
        .character-card.selected {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.15);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        .character-card h3 {
            font-size: 22px;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .character-card .char-type {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.4;
        }
        
        .char-stats {
            font-size: 11px;
            color: #ccc;
            margin-top: 10px;
            line-height: 1.6;
        }
        
        .char-stats div {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        
        .char-stats .stat-label {
            color: #aaa;
        }
        
        .char-stats .stat-value {
            color: #fff;
            font-weight: bold;
        }
        
        .start-game-btn {
            padding: 18px 50px;
            font-size: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            margin: 30px auto;
            display: block;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .start-game-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        
        .start-game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .controls-info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin: 30px auto;
            max-width: 1000px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .controls-info h3 {
            font-size: 24px;
            color: #fff;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .control-set {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-set h4 {
            font-size: 20px;
            margin-bottom: 15px;
            color: #4af;
            text-align: center;
        }
        
        .control-set.p2 h4 {
            color: #f44;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-item:last-child {
            border-bottom: none;
        }
        
        .control-label {
            color: #ccc;
            font-size: 14px;
        }
        
        .control-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 12px;
            border-radius: 5px;
            font-weight: bold;
            color: #fff;
            font-size: 14px;
            min-width: 40px;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            #characterSelect h1 {
                font-size: 32px;
            }
            
            .character-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            .character-card {
                padding: 15px;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="characterSelect">
        <div class="select-container">
            <h1>âš”ï¸ ã‚¹ãƒ†ã‚£ãƒƒã‚¯ãƒãƒ³æ ¼é—˜ã‚²ãƒ¼ãƒ  âš”ï¸</h1>
            
            <div class="controls-info">
                <h3>ğŸ® æ“ä½œæ–¹æ³•</h3>
                <div class="controls-grid">
                    <div class="control-set">
                        <h4>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1</h4>
                        <div class="control-item">
                            <span class="control-label">ç§»å‹•ï¼ˆå·¦å³ï¼‰</span>
                            <span class="control-key">â† â†’</span>
                        </div>
                        <div class="control-item">
                            <span class="control-label">ã‚¸ãƒ£ãƒ³ãƒ—</span>
                            <span class="control-key">â†‘</span>
                        </div>
                        <div class="control-item">
                            <span class="control-label">ã‚¬ãƒ¼ãƒ‰</span>
                            <span class="control-key">â†“</span>
                        </div>
                        <div class="control-item">
                            <span class="control-label">ãƒ‘ãƒ³ãƒ</span>
                            <span class="control-key">M</span>
                        </div>
                        <div class="control-item">
                            <span class="control-label">ã‚­ãƒƒã‚¯</span>
                            <span class="control-key">N</span>
                        </div>
                        <div class="control-item">
                            <span class="control-label">å¿…æ®ºæŠ€</span>
                            <span class="control-key">B</span>
                        </div>
                    </div>
                    
                    <div class="control-set p2">
                        <h4>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2</h4>
                        <div class="control-item">
                            <span class="control-label">ç§»å‹•ï¼ˆå·¦å³ï¼‰</span>
                            <span class="control-key">A D</span>
                        </div>
                        <div class="control-item">
                            <span class="control-label">ã‚¸ãƒ£ãƒ³ãƒ—</span>
                            <span class="control-key">W</span>
                        </div>
                        <div class="control-item">
                            <span class="control-label">ã‚¬ãƒ¼ãƒ‰</span>
                            <span class="control-key">S</span>
                        </div>
                        <div class="control-item">
                            <span class="control-label">ãƒ‘ãƒ³ãƒ</span>
                            <span class="control-key">G</span>
                        </div>
                        <div class="control-item">
                            <span class="control-label">ã‚­ãƒƒã‚¯</span>
                            <span class="control-key">H</span>
                        </div>
                        <div class="control-item">
                            <span class="control-label">å¿…æ®ºæŠ€</span>
                            <span class="control-key">J</span>
                        </div>
                    </div>
                </div>
                <p style="text-align: center; color: #aaa; margin-top: 15px; font-size: 14px;">
                    ãƒ¢ãƒã‚¤ãƒ«ç«¯æœ«ã§ã¯ã€ç”»é¢ä¸‹éƒ¨ã®ãƒœã‚¿ãƒ³ã§æ“ä½œã§ãã¾ã™
                </p>
                
                <div style="margin-top: 25px; padding: 15px; background: rgba(255, 255, 255, 0.03); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.1);">
                    <h4 style="color: #ffd700; margin-bottom: 15px; text-align: center; font-size: 18px;">ğŸŒŸ ç‰¹æ®Šèƒ½åŠ›ã‚³ãƒãƒ³ãƒ‰ ğŸŒŸ</h4>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; font-size: 13px; color: #ccc;">
        <div>
                            <strong style="color: #888;">Granite:</strong> è¿‘è·é›¢ã§<span style="color: #fff; font-weight: bold;">â†“ + ãƒ‘ãƒ³ãƒ</span> = æŠ•ã’æŠ€ï¼ˆé«˜ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
                        </div>
                        <div>
                            <strong style="color: #ff4;">Zen:</strong> ã‚¬ãƒ¼ãƒ‰æˆåŠŸå¾Œã«<span style="color: #fff; font-weight: bold;">è‡ªå‹•ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼</span>ç™ºå‹•
                        </div>
                        <div>
                            <strong style="color: #4f4;">Universal:</strong> <span style="color: #fff; font-weight: bold;">ç‰¹æ®Šã‚­ãƒ¼ + â†/â†’</span> = ç·Šæ€¥å›é¿ï¼ˆç„¡æ•µæ™‚é–“ï¼‰
                        </div>
                        <div>
                            <strong style="color: #f4f;">Mystia:</strong> è¿‘è·é›¢ã§<span style="color: #fff; font-weight: bold;">â†‘ + ã‚­ãƒƒã‚¯</span> = æŠ±æ“æŠ€
                        </div>
                        <div>
                            <strong style="color: #0ff;">Cyber-K:</strong> ã‚­ãƒƒã‚¯ã®<span style="color: #fff; font-weight: bold;">ç¯„å›²ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸</span>ãŒå¼·åŒ–
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="player-section">
            <h3 style="color: #4af;">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1</h3>
            <div class="character-grid" id="p1Select">
                <div class="character-card" data-char="ash">
                    <h3>Ash</h3>
                        <div class="char-type">ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰<br>ãƒãƒ©ãƒ³ã‚¹å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                        </div>
                </div>
                <div class="character-card" data-char="cyberK">
                    <h3>Cyber-K</h3>
                        <div class="char-type">ãƒŸãƒ‰ãƒ«ã‚­ãƒƒã‚¯<br>ã‚¹ãƒ”ãƒ¼ãƒ‰å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜…â˜…â˜…â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜†â˜†â˜†</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜…â˜…â˜…â˜†</span></div>
                        </div>
                </div>
                <div class="character-card" data-char="granite">
                    <h3>Granite</h3>
                        <div class="char-type">æŠ•ã’æŠ€<br>ãƒ‘ãƒ¯ãƒ¼å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜†â˜†â˜†â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜…â˜…â˜…</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜†â˜†â˜†â˜†</span></div>
                        </div>
                </div>
                <div class="character-card" data-char="mystia">
                    <h3>Mystia</h3>
                        <div class="char-type">æŠ±æ“&è†è¹´ã‚Š<br>ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜†â˜†â˜†</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜…â˜…â˜…â˜†</span></div>
                        </div>
                </div>
                <div class="character-card" data-char="zen">
                    <h3>Zen</h3>
                        <div class="char-type">ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼<br>é˜²å¾¡å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                        </div>
                </div>
                <div class="character-card" data-char="universal">
                    <h3>Universal</h3>
                        <div class="char-type">ç·Šæ€¥å›é¿<br>ä¸‡èƒ½å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                </div>
            </div>
        </div>
            </div>
            
            <div class="player-section">
            <h3 style="color: #f44;">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2</h3>
            <div class="character-grid" id="p2Select">
                <div class="character-card" data-char="ash">
                    <h3>Ash</h3>
                        <div class="char-type">ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰<br>ãƒãƒ©ãƒ³ã‚¹å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                        </div>
                </div>
                <div class="character-card" data-char="cyberK">
                    <h3>Cyber-K</h3>
                        <div class="char-type">ãƒŸãƒ‰ãƒ«ã‚­ãƒƒã‚¯<br>ã‚¹ãƒ”ãƒ¼ãƒ‰å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜…â˜…â˜…â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜†â˜†â˜†</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜…â˜…â˜…â˜†</span></div>
                        </div>
                </div>
                <div class="character-card" data-char="granite">
                    <h3>Granite</h3>
                        <div class="char-type">æŠ•ã’æŠ€<br>ãƒ‘ãƒ¯ãƒ¼å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜†â˜†â˜†â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜…â˜…â˜…</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜†â˜†â˜†â˜†</span></div>
                        </div>
                </div>
                <div class="character-card" data-char="mystia">
                    <h3>Mystia</h3>
                        <div class="char-type">æŠ±æ“&è†è¹´ã‚Š<br>ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜†â˜†â˜†</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜…â˜…â˜…â˜†</span></div>
                        </div>
                </div>
                <div class="character-card" data-char="zen">
                    <h3>Zen</h3>
                        <div class="char-type">ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼<br>é˜²å¾¡å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                        </div>
                </div>
                <div class="character-card" data-char="universal">
                    <h3>Universal</h3>
                        <div class="char-type">ç·Šæ€¥å›é¿<br>ä¸‡èƒ½å‹</div>
                        <div class="char-stats">
                            <div><span class="stat-label">ã‚¹ãƒ”ãƒ¼ãƒ‰:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ãƒ‘ãƒ¯ãƒ¼:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                            <div><span class="stat-label">ã‚¸ãƒ£ãƒ³ãƒ—:</span><span class="stat-value">â˜…â˜…â˜…â˜†â˜†</span></div>
                </div>
            </div>
        </div>
            </div>
            
            <button class="start-game-btn" id="startGameBtn" disabled>âš”ï¸ ã‚²ãƒ¼ãƒ é–‹å§‹ âš”ï¸</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div class="health-container">
            <div class="player-info-left">
            <div class="player-name player1-name" id="player1Name">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1</div>
                <div class="combo-display" id="player1Combo"></div>
            </div>
            <div class="health-bar-wrapper">
                <div class="health-bar">
                    <div class="health-fill" id="player1Health" style="width: 100%"></div>
                </div>
                <div class="guard-bar-wrapper">
                    <div class="guard-bar">
                        <div class="guard-fill" id="player1Guard" style="width: 100%"></div>
                    </div>
                </div>
                <div class="super-gauge-wrapper">
                    <div class="super-gauge-container" id="player1SuperGauge">
                        <div class="super-gauge-segment empty"></div>
                        <div class="super-gauge-segment empty"></div>
                        <div class="super-gauge-segment empty"></div>
                    </div>
                </div>
            </div>
            <div id="timer">99</div>
            <div id="roundInfo" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 1000; display: none;">
                <div id="roundText" style="font-size: 32px; margin-bottom: 5px;"></div>
                <div style="font-size: 18px; display: flex; gap: 20px; justify-content: center;">
                    <span id="player1Wins">0</span> - <span id="player2Wins">0</span>
                </div>
            </div>
            <div class="health-bar-wrapper">
                <div class="health-bar">
                    <div class="health-fill" id="player2Health" style="width: 100%"></div>
                </div>
                <div class="guard-bar-wrapper">
                    <div class="guard-bar">
                        <div class="guard-fill" id="player2Guard" style="width: 100%"></div>
            </div>
                </div>
                <div class="super-gauge-wrapper">
                    <div class="super-gauge-container" id="player2SuperGauge">
                        <div class="super-gauge-segment empty"></div>
                        <div class="super-gauge-segment empty"></div>
                        <div class="super-gauge-segment empty"></div>
                    </div>
                </div>
            </div>
            <div class="player-info-right">
            <div class="player-name player2-name" id="player2Name">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2</div>
                <div class="combo-display" id="player2Combo"></div>
            </div>
        </div>
    </div>
    
    <div id="controls">
        <button class="restart-btn" onclick="location.reload()">ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    </div>
    
    <div class="mobile-controls">
        <!-- å·¦å´ï¼šDãƒ‘ãƒƒãƒ‰é¢¨ã®åå­—ã‚­ãƒ¼ -->
        <div class="control-group">
            <div class="dpad-container">
                <div class="dpad-btn empty"></div>
                <button class="dpad-btn up" id="p1Up">â†‘</button>
                <div class="dpad-btn empty"></div>
                <button class="dpad-btn left" id="p1Left">â†</button>
                <div class="dpad-btn empty"></div>
                <button class="dpad-btn right" id="p1Right">â†’</button>
                <div class="dpad-btn empty"></div>
                <button class="dpad-btn down" id="p1Down">â†“</button>
                <div class="dpad-btn empty"></div>
            </div>
        </div>
        
        <!-- å³å´ï¼šã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ -->
        <div class="control-group">
            <div class="action-buttons">
                <button class="control-btn" id="p1Punch">ãƒ‘ãƒ³ãƒ</button>
                <button class="control-btn" id="p1Kick">ã‚­ãƒƒã‚¯</button>
                <button class="control-btn" id="p1Special">å¿…æ®º</button>
            </div>
        </div>
    </div>
    
    <div id="gameOver">
        <h1 id="winnerText">PLAYER 1 WIN!</h1>
        <p id="winMethod"></p>
        <button class="restart-btn" onclick="location.reload()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºè¨­å®šï¼ˆiOSå¯¾å¿œå¼·åŒ–ï¼‰
        function resizeCanvas() {
            // iOS Safariã®ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆé«˜ã•ã‚’æ­£ç¢ºã«å–å¾—
            const vh = window.innerHeight || document.documentElement.clientHeight;
            const vw = window.innerWidth || document.documentElement.clientWidth;
            const maxWidth = vw;
            const maxHeight = vh;
            const aspectRatio = 16 / 9;
            
            let canvasWidth, canvasHeight;
            
            if (maxWidth / maxHeight > aspectRatio) {
                canvasHeight = maxHeight;
                canvasWidth = maxHeight * aspectRatio;
            } else {
                canvasWidth = maxWidth;
                canvasHeight = maxWidth / aspectRatio;
            }
            
            // æœ€å°ã‚µã‚¤ã‚ºåˆ¶é™
            canvasWidth = Math.max(canvasWidth, 320);
            canvasHeight = Math.max(canvasHeight, 180);
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.width = canvasWidth + 'px';
            canvas.style.height = canvasHeight + 'px';
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100); // iOSã§å‘ãå¤‰æ›´å¾Œã«å°‘ã—é…å»¶
        });
        
        // iOSå‘ã‘ã®ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆé«˜ã•èª¿æ•´
        function setVH() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        setVH();
        window.addEventListener('resize', setVH);
        window.addEventListener('orientationchange', () => {
            setTimeout(setVH, 100);
        });
        
        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼å®šç¾©
        const characterData = {
            ash: {
                name: 'Ash',
                color: '#4af',
                speed: 5,
                jumpPower: 15,
                background: {
                    type: 'urban',
                    sky: ['#1a1a2e', '#16213e', '#0f3460'],
                    buildings: ['#2a2a3e', '#3a3a4e', '#4a4a5e'],
                    ground: '#1a1a1a',
                    theme: 'futuristic_city'
                },
                attacks: {
                    punch: { 
                        damage: 8, range: 60, startup: 5, recovery: 10,
                        cancelWindow: { start: 3, end: 7 }, // ãƒ’ãƒƒãƒˆå¾Œã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ãªãƒ•ãƒ¬ãƒ¼ãƒ 
                        cancellableInto: ['kick', 'special'] // ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ãªæŠ€
                    },
                    kick: { 
                        damage: 12, range: 80, startup: 9, recovery: 15,
                        cancelWindow: { start: 6, end: 12 },
                        cancellableInto: ['special']
                    },
                    special: { 
                        damage: 25, range: 120, startup: 15, recovery: 30, name: 'Ultimate Impact',
                        cancelWindow: null,
                        cancellableInto: []
                    }
                },
                superMove: {
                    name: 'FINAL IMPACT',
                    damage: 45,
                    range: 150,
                    startup: 20,
                    recovery: 40,
                    gaugeCost: 200, // 2ã‚²ãƒ¼ã‚¸æ¶ˆè²»
                    command: ['down', 'down', 'forward', 'forward', 'punch']
                }
            },
            cyberK: {
                name: 'Cyber-K',
                color: '#0ff',
                speed: 7,
                jumpPower: 18,
                background: {
                    type: 'cyber',
                    sky: ['#000428', '#004e92', '#009ffd'],
                    buildings: ['#00d4ff', '#0099cc', '#006699'],
                    ground: '#001a33',
                    theme: 'cyberpunk'
                },
                attacks: {
                    punch: { 
                        damage: 7, range: 55, startup: 3, recovery: 8,
                        cancelWindow: { start: 2, end: 5 },
                        cancellableInto: ['kick', 'special']
                    },
                    kick: { 
                        damage: 15, range: 100, startup: 8, recovery: 12,
                        cancelWindow: { start: 5, end: 10 },
                        cancellableInto: ['special']
                    },
                    special: { 
                        damage: 22, range: 110, startup: 10, recovery: 25, name: 'Middle Kick',
                        cancelWindow: null,
                        cancellableInto: []
                    }
                },
                superMove: {
                    name: 'CYBER STORM',
                    damage: 42,
                    range: 140,
                    startup: 18,
                    recovery: 35,
                    gaugeCost: 200,
                    command: ['down', 'forward', 'down', 'forward', 'kick']
                }
            },
            granite: {
                name: 'Granite',
                color: '#888',
                speed: 3,
                jumpPower: 10,
                background: {
                    type: 'mountain',
                    sky: ['#2c1810', '#3d2317', '#4a2c1f'],
                    buildings: ['#654321', '#8b4513', '#a0522d'],
                    ground: '#5a4a3a',
                    theme: 'rocky_mountain'
                },
                attacks: {
                    punch: { 
                        damage: 15, range: 70, startup: 8, recovery: 15,
                        cancelWindow: { start: 6, end: 11 },
                        cancellableInto: ['kick', 'special']
                    },
                    kick: { 
                        damage: 10, range: 60, startup: 10, recovery: 12,
                        cancelWindow: { start: 7, end: 13 },
                        cancellableInto: ['special']
                    },
                    special: { 
                        damage: 30, range: 80, startup: 20, recovery: 35, name: 'Granit Press',
                        cancelWindow: null,
                        cancellableInto: []
                    }
                },
                superMove: {
                    name: 'MOUNTAIN CRUSHER',
                    damage: 50,
                    range: 120,
                    startup: 25,
                    recovery: 45,
                    gaugeCost: 200,
                    command: ['down', 'down', 'down', 'punch']
                }
            },
            mystia: {
                name: 'Mystia',
                color: '#f4f',
                speed: 6,
                jumpPower: 16,
                background: {
                    type: 'mystical',
                    sky: ['#1a0033', '#330066', '#660099'],
                    buildings: ['#9933cc', '#cc66ff', '#ff99ff'],
                    ground: '#4d004d',
                    theme: 'magical_forest'
                },
                attacks: {
                    punch: { 
                        damage: 6, range: 50, startup: 4, recovery: 8,
                        cancelWindow: { start: 3, end: 6 },
                        cancellableInto: ['kick', 'special']
                    },
                    kick: { 
                        damage: 14, range: 70, startup: 7, recovery: 10,
                        cancelWindow: { start: 5, end: 9 },
                        cancellableInto: ['special']
                    },
                    special: { 
                        damage: 28, range: 90, startup: 12, recovery: 28, name: 'Mujihi na Hoyo',
                        cancelWindow: null,
                        cancellableInto: []
                    }
                },
                superMove: {
                    name: 'ETERNAL EMBRACE',
                    damage: 40,
                    range: 130,
                    startup: 15,
                    recovery: 30,
                    gaugeCost: 200,
                    command: ['down', 'forward', 'down', 'forward', 'kick']
                }
            },
            zen: {
                name: 'Zen',
                color: '#ff4',
                speed: 5,
                jumpPower: 14,
                background: {
                    type: 'temple',
                    sky: ['#ffeaa7', '#fdcb6e', '#e17055'],
                    buildings: ['#dfe6e9', '#b2bec3', '#636e72'],
                    ground: '#fab1a0',
                    theme: 'peaceful_temple'
                },
                attacks: {
                    punch: { 
                        damage: 10, range: 65, startup: 6, recovery: 12,
                        cancelWindow: { start: 4, end: 8 },
                        cancellableInto: ['kick', 'special']
                    },
                    kick: { 
                        damage: 11, range: 75, startup: 8, recovery: 13,
                        cancelWindow: { start: 6, end: 11 },
                        cancellableInto: ['special']
                    },
                    special: { 
                        damage: 20, range: 85, startup: 8, recovery: 20, name: 'Kuusemi-gaashi',
                        cancelWindow: null,
                        cancellableInto: []
                    }
                },
                superMove: {
                    name: 'TRANSCENDENT STRIKE',
                    damage: 38,
                    range: 125,
                    startup: 12,
                    recovery: 28,
                    gaugeCost: 200,
                    command: ['down', 'back', 'down', 'forward', 'punch']
                }
            },
            universal: {
                name: 'Universal',
                color: '#4f4',
                speed: 6,
                jumpPower: 15,
                background: {
                    type: 'space',
                    sky: ['#000000', '#1a0033', '#330066'],
                    buildings: ['#00ff88', '#00cc66', '#009944'],
                    ground: '#001a1a',
                    theme: 'cosmic_arena'
                },
                attacks: {
                    punch: { 
                        damage: 9, range: 60, startup: 5, recovery: 10,
                        cancelWindow: { start: 3, end: 7 },
                        cancellableInto: ['kick', 'special']
                    },
                    kick: { 
                        damage: 13, range: 75, startup: 8, recovery: 13,
                        cancelWindow: { start: 6, end: 11 },
                        cancellableInto: ['special']
                    },
                    special: { 
                        damage: 24, range: 100, startup: 12, recovery: 25, name: 'Emergency Step',
                        cancelWindow: null,
                        cancellableInto: []
                    }
                },
                superMove: {
                    name: 'COSMIC ANNIHILATION',
                    damage: 44,
                    range: 145,
                    startup: 16,
                    recovery: 32,
                    gaugeCost: 200,
                    command: ['down', 'forward', 'down', 'forward', 'special']
                }
            }
        };
        
        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼é¸æŠ
        let selectedP1 = null;
        let selectedP2 = null;
        
        document.querySelectorAll('#p1Select .character-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('#p1Select .character-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selectedP1 = card.dataset.char;
                updateStartButton();
            });
        });
        
        document.querySelectorAll('#p2Select .character-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('#p2Select .character-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
                selectedP2 = card.dataset.char;
                updateStartButton();
            });
        });
        
        function updateStartButton() {
            const btn = document.getElementById('startGameBtn');
            if (selectedP1 && selectedP2) {
                btn.disabled = false;
            }
        }
        
        document.getElementById('startGameBtn').addEventListener('click', () => {
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œæ™‚ã«AudioContextã‚’åˆæœŸåŒ–
            initAudioContexts();
            resumeAudioContexts();
            
            document.getElementById('characterSelect').style.display = 'none';
            initGame();
        });
        
        // ã‚²ãƒ¼ãƒ å¤‰æ•°
        let player1, player2;
        let keys = {};
        let gameRunning = false;
        let gameTime = 99;
        let lastTime = Date.now();
        
        // ãƒ©ã‚¦ãƒ³ãƒ‰åˆ¶ã‚·ã‚¹ãƒ†ãƒ 
        let currentRound = 1;
        let maxRounds = 3;
        let player1Wins = 0;
        let player2Wins = 0;
        let roundStarting = false;
        let roundStartFrames = 0;
        let roundStartMessage = '';
        
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ 
        const particles = [];
        
        // ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å­—ã‚·ã‚¹ãƒ†ãƒ 
        const damageNumbers = [];
        
        // ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«è¡¨ç¤ºã‚·ã‚¹ãƒ†ãƒ 
        const criticalTexts = [];
        
        // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯ã‚·ã‚¹ãƒ†ãƒ 
        let cameraShake = { x: 0, y: 0, frames: 0, intensity: 0 };
        
        // ã‚¹ãƒ­ãƒ¼ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ 
        let slowMotionActive = false;
        let slowMotionFrames = 0;
        let slowMotionSpeed = 1.0;
        
        // éŸ³éŸ¿åŠ¹æœã‚·ã‚¹ãƒ†ãƒ ï¼ˆ2ã¤ã®AudioContextã«åˆ†é›¢ï¼‰
        // åŠ¹æœéŸ³ç”¨ã®AudioContext
        let seAudioContext = null;
        // BGMç”¨ã®AudioContext
        let bgmAudioContext = null;
        
        // AudioContextã®åˆæœŸåŒ–é–¢æ•°ï¼ˆiOSå¯¾å¿œå¼·åŒ–ï¼‰
        function initAudioContexts() {
            try {
                if (!seAudioContext) {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    seAudioContext = new AudioContextClass();
                    
                    // iOS Safari 13+å‘ã‘ã®è¨­å®š
                    if (seAudioContext.state === 'suspended') {
                        seAudioContext.resume();
                    }
                }
                if (!bgmAudioContext) {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    bgmAudioContext = new AudioContextClass();
                    
                    // iOS Safari 13+å‘ã‘ã®è¨­å®š
                    if (bgmAudioContext.state === 'suspended') {
                        bgmAudioContext.resume();
                    }
                }
            } catch (e) {
                console.warn('AudioContextåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', e);
            }
        }
        
        // AudioContextã®å¾©å…ƒé–¢æ•°ï¼ˆiOSå¯¾å¿œå¼·åŒ–ï¼‰
        function resumeAudioContexts() {
            try {
                if (seAudioContext) {
                    if (seAudioContext.state === 'suspended') {
                        seAudioContext.resume().catch(e => {
                            console.warn('SE AudioContextå¾©å…ƒã‚¨ãƒ©ãƒ¼:', e);
                        });
                    }
                }
                if (bgmAudioContext) {
                    if (bgmAudioContext.state === 'suspended') {
                        bgmAudioContext.resume().catch(e => {
                            console.warn('BGM AudioContextå¾©å…ƒã‚¨ãƒ©ãƒ¼:', e);
                        });
                    }
                }
            } catch (e) {
                console.warn('AudioContextå¾©å…ƒã‚¨ãƒ©ãƒ¼:', e);
            }
        }
        
        // iOSå‘ã‘ï¼šæœ€åˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œæ™‚ã«AudioContextã‚’å¾©å…ƒ
        function enableAudioOnFirstInteraction() {
            const enableAudio = () => {
                initAudioContexts();
                resumeAudioContexts();
                document.removeEventListener('touchstart', enableAudio);
                document.removeEventListener('click', enableAudio);
            };
            
            document.addEventListener('touchstart', enableAudio, { once: true });
            document.addEventListener('click', enableAudio, { once: true });
        }
        
        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«æº–å‚™
        enableAudioOnFirstInteraction();
        
        // éŸ³éŸ¿åŠ¹æœç”Ÿæˆé–¢æ•°ï¼ˆåŠ¹æœéŸ³ç”¨AudioContextã‚’ä½¿ç”¨ï¼‰
        function playSound(frequency, duration, type = 'sine', volume = 0.3) {
            try {
                if (!seAudioContext) {
                    initAudioContexts();
                }
                if (seAudioContext.state === 'suspended') {
                    seAudioContext.resume();
                }
                
                const oscillator = seAudioContext.createOscillator();
                const gainNode = seAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(seAudioContext.destination);
                
                oscillator.type = type;
                oscillator.frequency.value = frequency;
                
                gainNode.gain.setValueAtTime(volume, seAudioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, seAudioContext.currentTime + duration);
                
                oscillator.start(seAudioContext.currentTime);
                oscillator.stop(seAudioContext.currentTime + duration);
            } catch (e) {
                // éŸ³å£°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒä½¿ãˆãªã„å ´åˆã¯ç„¡è¦–
            }
        }
        
        function playPunchSound() {
            // ãƒ‘ãƒ³ãƒéŸ³ï¼šçŸ­ã„é«˜éŸ³
            playSound(200, 0.05, 'sawtooth', 0.2);
            playSound(300, 0.03, 'square', 0.15);
        }
        
        function playKickSound() {
            // ã‚­ãƒƒã‚¯éŸ³ï¼šä½ã‚ã®éŸ³
            playSound(150, 0.08, 'sawtooth', 0.25);
            playSound(200, 0.05, 'square', 0.2);
        }
        
        function playHitSound(isCritical = false) {
            // ãƒ’ãƒƒãƒˆéŸ³
            if (isCritical) {
                playSound(400, 0.1, 'sine', 0.4);
                playSound(600, 0.08, 'sine', 0.3);
            } else {
                playSound(300, 0.06, 'sawtooth', 0.25);
                playSound(200, 0.04, 'square', 0.2);
            }
        }
        
        function playGuardSound() {
            // ã‚¬ãƒ¼ãƒ‰éŸ³ï¼šé‡‘å±çš„ãªéŸ³
            playSound(400, 0.1, 'sine', 0.3);
            playSound(600, 0.05, 'sine', 0.2);
        }
        
        function playGuardCrushSound() {
            // ã‚¬ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥éŸ³ï¼šç ´è£‚éŸ³
            playSound(150, 0.2, 'sawtooth', 0.5);
            playSound(100, 0.15, 'sawtooth', 0.4);
        }
        
        function playSuperMoveSound(charType) {
            // è¶…å¿…æ®ºæŠ€éŸ³ï¼šè¿«åŠ›ã®ã‚ã‚‹éŸ³
            playSound(100, 0.15, 'sawtooth', 0.5);
            playSound(200, 0.12, 'square', 0.4);
            playSound(400, 0.1, 'sine', 0.3);
            setTimeout(() => {
                playSound(300, 0.2, 'sawtooth', 0.4);
                playSound(500, 0.15, 'sine', 0.3);
            }, 100);
        }
        
        // ç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ 
        let screenFlash = { active: false, frames: 0, color: '#fff' };
        
        function createScreenFlash(color) {
            screenFlash.active = true;
            screenFlash.frames = 10;
            screenFlash.color = color;
        }
        
        function playSpecialSound(charType) {
            // å¿…æ®ºæŠ€ã”ã¨ã®éŸ³
            switch(charType) {
                case 'ash':
                    playSound(300, 0.15, 'sine', 0.4);
                    playSound(500, 0.12, 'sine', 0.3);
                    break;
                case 'cyberK':
                    playSound(400, 0.12, 'square', 0.35);
                    playSound(600, 0.1, 'sine', 0.25);
                    break;
                case 'granite':
                    playSound(100, 0.2, 'sawtooth', 0.5);
                    playSound(150, 0.18, 'sawtooth', 0.4);
                    break;
                case 'mystia':
                    playSound(350, 0.1, 'sine', 0.3);
                    playSound(450, 0.08, 'sine', 0.25);
                    break;
                case 'zen':
                    playSound(500, 0.08, 'sine', 0.3);
                    playSound(700, 0.06, 'sine', 0.2);
                    break;
                case 'universal':
                    playSound(300, 0.1, 'square', 0.3);
                    playSound(400, 0.08, 'sine', 0.25);
                    break;
            }
        }
        
        function playKOSound() {
            // KOéŸ³ï¼šä½ã„ç ´è£‚éŸ³
            playSound(80, 0.3, 'sawtooth', 0.6);
            playSound(120, 0.25, 'sawtooth', 0.5);
            setTimeout(() => {
                playSound(100, 0.2, 'sawtooth', 0.4);
            }, 200);
        }
        
        function playVictorySound() {
            // å‹åˆ©éŸ³ï¼šä¸Šæ˜‡ã™ã‚‹éŸ³éš
            const notes = [262, 330, 392, 523]; // C, E, G, C
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    playSound(freq, 0.3, 'sine', 0.3);
                }, i * 150);
            });
        }
        
        let bgmPlaying = false;
        let bgmGainNode = null;
        let bgmIntervals = []; // BGMç”¨ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ç®¡ç†
        
        function playBGM() {
            // ãƒãƒˆãƒ«BGMï¼šä½ã„ãƒ“ãƒ¼ãƒˆã¨ãƒ¡ãƒ­ãƒ‡ã‚£ï¼ˆBGMç”¨AudioContextã‚’ä½¿ç”¨ï¼‰
            if (bgmPlaying) return;
            
            try {
                if (!bgmAudioContext) {
                    initAudioContexts();
                }
                if (bgmAudioContext.state === 'suspended') {
                    bgmAudioContext.resume();
                }
                
                bgmPlaying = true;
                
                bgmGainNode = bgmAudioContext.createGain();
                bgmGainNode.gain.value = 0.15;
                bgmGainNode.connect(bgmAudioContext.destination);
                
                // ãƒ“ãƒ¼ãƒˆç”Ÿæˆ
                const beatInterval = setInterval(() => {
                    if (!bgmPlaying || !bgmAudioContext) {
                        clearInterval(beatInterval);
                        return;
                    }
                    try {
                        const beat = bgmAudioContext.createOscillator();
                        const beatGain = bgmAudioContext.createGain();
                        beat.connect(beatGain);
                        beatGain.connect(bgmGainNode);
                        beat.type = 'square';
                        beat.frequency.value = 60;
                        beatGain.gain.setValueAtTime(0.1, bgmAudioContext.currentTime);
                        beatGain.gain.exponentialRampToValueAtTime(0.01, bgmAudioContext.currentTime + 0.1);
                        beat.start();
                        beat.stop(bgmAudioContext.currentTime + 0.1);
                    } catch (e) {
                        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢
                        clearInterval(beatInterval);
                    }
                }, 500);
                bgmIntervals.push(beatInterval);
                
                // ãƒ¡ãƒ­ãƒ‡ã‚£ï¼ˆãƒ«ãƒ¼ãƒ—ï¼‰
                let noteIndex = 0;
                const melodyNotes = [262, 294, 330, 349, 392, 440, 494, 523]; // Cãƒ¡ã‚¸ãƒ£ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«
                const melodyInterval = setInterval(() => {
                    if (!bgmPlaying || !bgmAudioContext) {
                        clearInterval(melodyInterval);
                        return;
                    }
                    try {
                        const note = bgmAudioContext.createOscillator();
                        const noteGain = bgmAudioContext.createGain();
                        note.connect(noteGain);
                        noteGain.connect(bgmGainNode);
                        note.type = 'sine';
                        note.frequency.value = melodyNotes[noteIndex % melodyNotes.length];
                        noteGain.gain.setValueAtTime(0.05, bgmAudioContext.currentTime);
                        noteGain.gain.exponentialRampToValueAtTime(0.01, bgmAudioContext.currentTime + 0.5);
                        note.start();
                        note.stop(bgmAudioContext.currentTime + 0.5);
                        noteIndex++;
                    } catch (e) {
                        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢
                        clearInterval(melodyInterval);
                    }
                }, 600);
                bgmIntervals.push(melodyInterval);
            } catch (e) {
                console.warn('BGMå†ç”Ÿã‚¨ãƒ©ãƒ¼:', e);
                bgmPlaying = false;
            }
        }
        
        function stopBGM() {
            bgmPlaying = false;
            
            // ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚’ã‚¯ãƒªã‚¢
            bgmIntervals.forEach(interval => clearInterval(interval));
            bgmIntervals = [];
            
            if (bgmGainNode && bgmAudioContext) {
                try {
                    bgmGainNode.gain.exponentialRampToValueAtTime(0.01, bgmAudioContext.currentTime + 0.5);
                    setTimeout(() => {
                        if (bgmGainNode) {
                            bgmGainNode.disconnect();
                            bgmGainNode = null;
                        }
                    }, 500);
                } catch (e) {
                    bgmGainNode = null;
                }
            }
        }
        
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8 - 2;
                this.life = 30;
                this.maxLife = 30;
                this.color = color;
                this.size = Math.random() * 4 + 2;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.3;
                this.life--;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                ctx.restore();
            }
        }
        
        class DamageNumber {
            constructor(x, y, damage, isCritical, comboCount) {
                this.x = x;
                this.y = y;
                this.damage = Math.round(damage);
                this.isCritical = isCritical;
                this.comboCount = comboCount || 1;
                this.vx = (Math.random() - 0.5) * 3;
                this.vy = -5 - Math.random() * 3;
                this.life = 60;
                this.maxLife = 60;
                this.scale = isCritical ? 1.5 : 1.0;
                this.rotation = (Math.random() - 0.5) * 0.3;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2;
                this.life--;
                if (this.life < 20) {
                    this.scale *= 0.95; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆæ™‚ã«ç¸®å°
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.scale(this.scale, this.scale);
                
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                
                // ã‚³ãƒ³ãƒœæ•°ã«å¿œã˜ãŸè‰²
                let color = '#fff';
                if (this.isCritical) {
                    color = '#ff0';
                } else if (this.comboCount >= 5) {
                    color = '#f0f';
                } else if (this.comboCount >= 3) {
                    color = '#f88';
                }
                
                // æ•°å­—ã‚’æç”»
                ctx.fillStyle = color;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.font = `bold ${30 + this.comboCount * 2}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeText(`-${this.damage}`, 0, 0);
                ctx.fillText(`-${this.damage}`, 0, 0);
                
                // ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«æ™‚ã¯ã€Œ!ã€ã‚‚è¡¨ç¤º
                if (this.isCritical) {
                    ctx.font = 'bold 40px Arial';
                    ctx.strokeText('!', 35, -10);
                    ctx.fillText('!', 35, -10);
                }
                
                ctx.restore();
            }
        }
        
        class CriticalText {
            constructor(x, y, text) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.life = 90;
                this.maxLife = 90;
                this.vy = -2;
                this.scale = 0;
                this.targetScale = 1.5;
            }
            
            update() {
                this.y += this.vy;
                this.life--;
                
                // ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.life > 60) {
                    this.scale = (this.maxLife - this.life) / 30 * this.targetScale;
                } else if (this.life < 20) {
                    this.scale = (this.life / 20) * this.targetScale;
                } else {
                    this.scale = this.targetScale;
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.scale, this.scale);
                
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                
                ctx.fillStyle = '#ff0';
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 6;
                ctx.font = 'bold 50px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeText(this.text, 0, 0);
                ctx.fillText(this.text, 0, 0);
                
                // å…‰ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0';
                ctx.fillText(this.text, 0, 0);
                
                ctx.restore();
            }
        }
        
        function shakeCamera(intensity, frames) {
            cameraShake.frames = frames;
            cameraShake.intensity = intensity;
        }
        
        function startSlowMotion(speed, frames) {
            slowMotionActive = true;
            slowMotionFrames = frames;
            slowMotionSpeed = speed;
        }
        
        class Player {
            constructor(x, y, controls, charType, facing, isCPU = false) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 80;
                this.vx = 0;
                this.vy = 0;
                this.controls = controls;
                this.facing = facing;
                this.onGround = false;
                this.isCPU = isCPU;
                
                // CPUç”¨ã®å¤‰æ•°
                if (isCPU) {
                    this.aiReactionTime = 0;
                    this.aiActionCooldown = 0;
                    this.aiState = 'idle'; // 'idle', 'approach', 'attack', 'defend', 'retreat'
                    this.aiTargetDistance = 0;
                }
                
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç‰¹æ€§
                const charData = characterData[charType];
                this.name = charData.name;
                this.color = charData.color;
                this.speed = charData.speed;
                this.jumpPower = charData.jumpPower;
                this.attacks = charData.attacks;
                this.charType = charType; // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¿ã‚¤ãƒ—ã‚’ä¿å­˜
                
                // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
                this.health = 100;
                this.maxHealth = 100;
                this.isAttacking = false;
                this.attackType = null;
                this.attackFrame = 0;
                this.isBlocking = false;
                this.stunned = 0;
                this.invincible = 0;
                
                // ã‚³ãƒ³ãƒœã‚·ã‚¹ãƒ†ãƒ 
                this.comboCount = 0;
                this.comboTimer = 0;
                this.comboWindow = 60; // ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼ˆç´„1ç§’ï¼‰
                
                // ã‚¬ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã‚·ã‚¹ãƒ†ãƒ 
                this.guardGauge = 100;
                this.maxGuardGauge = 100;
                this.guardCrushed = false;
                this.guardCrushedTime = 0;
                
                // è¶…å¿…æ®ºæŠ€ï¼ˆã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚³ãƒ³ãƒœï¼‰ã‚·ã‚¹ãƒ†ãƒ 
                this.superGauge = 0; // ç¾åœ¨ã®ã‚²ãƒ¼ã‚¸ï¼ˆ0-300ã€1ã‚²ãƒ¼ã‚¸=100ï¼‰
                this.maxSuperGauge = 300; // æœ€å¤§3ã‚²ãƒ¼ã‚¸
                this.superGaugeGainOnHit = 15; // æ”»æ’ƒå‘½ä¸­æ™‚ã®ã‚²ãƒ¼ã‚¸å¢—åŠ é‡
                this.superGaugeGainOnBlock = 8; // ã‚¬ãƒ¼ãƒ‰æ™‚ã®ã‚²ãƒ¼ã‚¸å¢—åŠ é‡
                this.superGaugeGainOnDamage = 20; // è¢«å¼¾æ™‚ã®ã‚²ãƒ¼ã‚¸å¢—åŠ é‡
                this.superMoveActive = false; // è¶…å¿…æ®ºæŠ€ç™ºå‹•ä¸­ã‹
                this.superMoveFrame = 0; // è¶…å¿…æ®ºæŠ€ã®ãƒ•ãƒ¬ãƒ¼ãƒ 
                this.superMoveName = null; // è¶…å¿…æ®ºæŠ€å
                
                // ãƒ’ãƒƒãƒˆã‚¹ãƒˆãƒƒãƒ—
                this.hitStopFrames = 0;
                this.hitStopActive = false;
                
                // ç‰¹æ®Šèƒ½åŠ›ã‚·ã‚¹ãƒ†ãƒ 
                this.specialAbilityActive = false;
                this.specialAbilityType = null;
                this.specialAbilityFrame = 0;
                this.counterReady = false; // Zenã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼å¾…æ©ŸçŠ¶æ…‹
                this.evadeFrames = 0; // Universalã®å›é¿ãƒ•ãƒ¬ãƒ¼ãƒ 
                
                // ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›ã‚·ã‚¹ãƒ†ãƒ 
                this.inputHistory = []; // å…¥åŠ›å±¥æ­´
                this.inputBufferTime = 20; // å…¥åŠ›ãƒãƒƒãƒ•ã‚¡æ™‚é–“ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
                this.specialMoveName = null; // ç™ºå‹•ã—ãŸå¿…æ®ºæŠ€å
                this.specialMoveNameFrames = 0; // å¿…æ®ºæŠ€åè¡¨ç¤ºæ™‚é–“
                
                // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã‚·ã‚¹ãƒ†ãƒ 
                this.lastHitConnected = false; // æœ€å¾Œã®æ”»æ’ƒãŒãƒ’ãƒƒãƒˆã—ãŸã‹
                this.guardCrushComboReady = false; // ã‚¬ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥å¾Œã®ç¢ºå®šã‚³ãƒ³ãƒœå¯èƒ½çŠ¶æ…‹
                this.jumpAttackHit = false; // ã‚¸ãƒ£ãƒ³ãƒ—æ”»æ’ƒãŒãƒ’ãƒƒãƒˆã—ãŸã‹
                this.airComboReady = false; // ç©ºä¸­ã‚³ãƒ³ãƒœå¯èƒ½çŠ¶æ…‹
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                this.animFrame = 0;
                this.animSpeed = 0.2;
            }
            
            update() {
                // ãƒ’ãƒƒãƒˆã‚¹ãƒˆãƒƒãƒ—ä¸­ã¯å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
                if (this.hitStopActive && this.hitStopFrames > 0) {
                    this.hitStopFrames--;
                    if (this.hitStopFrames <= 0) {
                        this.hitStopActive = false;
                    }
                    return;
                }
                
                // CPUã®å ´åˆã¯AIãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè¡Œ
                if (this.isCPU) {
                    this.updateCPU();
                }
                
                // ã‚¹ã‚¿ãƒ³/ç„¡æ•µæ™‚é–“
                if (this.stunned > 0) {
                    this.stunned--;
                    if (this.isCPU) {
                        this.aiReactionTime = 10; // ã‚¹ã‚¿ãƒ³ä¸­ã¯AIåå¿œæ™‚é–“ã‚’ãƒªã‚»ãƒƒãƒˆ
                    }
                    return;
                }
                if (this.invincible > 0) this.invincible--;
                
                // ã‚¬ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥çŠ¶æ…‹ã®æ›´æ–°
                if (this.guardCrushed) {
                    this.guardCrushedTime--;
                    if (this.guardCrushedTime <= 0) {
                        this.guardCrushed = false;
                        this.guardGauge = this.maxGuardGauge; // ã‚¬ãƒ¼ãƒ‰ã‚²ãƒ¼ã‚¸å›å¾©
                    }
                }
                
                // ã‚³ãƒ³ãƒœã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°
                if (this.comboTimer > 0) {
                    this.comboTimer--;
                    if (this.comboTimer <= 0) {
                        this.comboCount = 0; // ã‚³ãƒ³ãƒœãƒªã‚»ãƒƒãƒˆ
                    }
                }
                
                // è¶…å¿…æ®ºæŠ€ä¸­ã®å‡¦ç†
                if (this.superMoveActive) {
                    this.superMoveFrame++;
                    this.attackFrame++;
                    const charData = characterData[this.charType];
                    const superMove = charData.superMove;
                    
                    if (this.attackFrame === superMove.startup) {
                        this.performSuperMove();
                    }
                    
                    if (this.attackFrame >= superMove.startup + superMove.recovery) {
                        this.superMoveActive = false;
                        this.superMoveFrame = 0;
                        this.isAttacking = false;
                        this.attackFrame = 0;
                        this.attackType = null;
                    }
                    
                    // è¶…å¿…æ®ºæŠ€ä¸­ã‚‚é‡åŠ›é©ç”¨
                    this.vy += 0.8;
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    const groundY = canvas.height - 100;
                    if (this.y + this.height >= groundY) {
                        this.y = groundY - this.height;
                        this.vy = 0;
                        this.onGround = true;
                    }
                    
                    this.updateInputHistory();
                    this.animFrame += this.animSpeed;
                    return;
                }
                
                // æ”»æ’ƒä¸­ã®å‡¦ç†
                if (this.isAttacking) {
                    this.attackFrame++;
                    const attack = this.attacks[this.attackType];
                    
                    if (this.attackFrame === attack.startup) {
                        const hitResult = this.performAttack();
                        // ãƒ’ãƒƒãƒˆã—ãŸå ´åˆã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
                        if (hitResult && hitResult.hit) {
                            this.lastHitConnected = true;
                        }
                    }
                    
                    // ã‚­ãƒ£ãƒ³ã‚»ãƒ«åˆ¤å®šï¼ˆãƒ’ãƒƒãƒˆæ™‚ã®ã¿å¯èƒ½ã€ãƒ’ãƒƒãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ä»¥é™ï¼‰
                    if (this.attackFrame > attack.startup && this.canCancelAttack(attack) && !this.isCPU) {
                        const cancelType = this.checkCancelInput();
                        if (cancelType) {
                            // ã‚­ãƒ£ãƒ³ã‚»ãƒ«å®Ÿè¡Œ
                            this.isAttacking = false;
                            this.attackFrame = 0;
                            this.lastHitConnected = false;
                            this.startAttack(cancelType);
                            return; // æ–°ã—ã„æ”»æ’ƒã‚’é–‹å§‹
                        }
                    }
                    
                    if (this.attackFrame >= attack.startup + attack.recovery) {
                        this.isAttacking = false;
                        this.attackFrame = 0;
                        this.lastHitConnected = false; // ãƒªã‚»ãƒƒãƒˆ
                    }
                    
                    // æ”»æ’ƒä¸­ã§ã‚‚é‡åŠ›ã¨ä½ç½®æ›´æ–°ã¯é©ç”¨ï¼ˆã‚¸ãƒ£ãƒ³ãƒ—ä¸­ã§ã‚‚è½ä¸‹ã™ã‚‹ï¼‰
                    // ãŸã ã—ç§»å‹•å…¥åŠ›ã¯åˆ¶é™ï¼ˆè»½ãã ã‘åˆ¶é™ï¼‰
                    if (this.onGround) {
                        this.vx = 0; // åœ°ä¸Šã§ã¯ç§»å‹•ä¸å¯
                    } else {
                        // ç©ºä¸­ã§ã¯å°‘ã—ã ã‘ç§»å‹•å¯èƒ½
                        this.vx *= 0.9; // æ¸›é€Ÿ
                    }
                    
                    // é‡åŠ›é©ç”¨
                    this.vy += 0.8;
                    
                    // ä½ç½®æ›´æ–°
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // åœ°é¢åˆ¤å®š
                    const groundY = canvas.height - 100;
                    if (this.y + this.height >= groundY) {
                        this.y = groundY - this.height;
                        this.vy = 0;
                        const wasInAir = !this.onGround;
                        this.onGround = true;
                        
                        // ã‚¸ãƒ£ãƒ³ãƒ—æ”»æ’ƒã‹ã‚‰ã®è¿½æ’ƒã‚³ãƒ³ãƒœï¼ˆç€åœ°ç›´å¾Œï¼‰
                        if (wasInAir && this.airComboReady && !this.isAttacking) {
                            // ã‚³ãƒ³ãƒœã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å»¶é•·ï¼ˆç€åœ°å¾Œã«ã™ãæ”»æ’ƒã™ã‚Œã°ã‚³ãƒ³ãƒœç¶™ç¶šï¼‰
                            this.comboTimer = this.comboWindow;
                        } else if (this.onGround && !this.airComboReady) {
                            // åœ°é¢ã«ç€åœ°ã—ãŸã‚‰ç©ºä¸­ã‚³ãƒ³ãƒœãƒ•ãƒ©ã‚°ãƒªã‚»ãƒƒãƒˆ
                            this.jumpAttackHit = false;
                        }
                    }
                    
                    // ç”»é¢ç«¯
                    if (this.x < 0) this.x = 0;
                    if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
                    
                    // å…¥åŠ›å±¥æ­´ã®ç®¡ç†ã¨ã‚³ãƒãƒ³ãƒ‰åˆ¤å®šã¯ç¶šè¡Œï¼ˆæ¬¡ã®æ”»æ’ƒæº–å‚™ï¼‰
                    this.updateInputHistory();
                    this.animFrame += this.animSpeed;
                    return;
                }
                
                // ç§»å‹•
                this.vx = 0;
                this.isBlocking = false;
                
                if (keys[this.controls.left]) {
                    this.vx = -this.speed;
                    this.facing = -1;
                }
                if (keys[this.controls.right]) {
                    this.vx = this.speed;
                    this.facing = 1;
                }
                if (keys[this.controls.down]) {
                    this.isBlocking = true;
                }
                if (keys[this.controls.up] && this.onGround) {
                    this.vy = -this.jumpPower;
                    this.onGround = false;
                }
                
                // ç‰¹æ®Šèƒ½åŠ›å‡¦ç†
                if (this.specialAbilityActive) {
                    this.updateSpecialAbility();
                    
                    // ç‰¹æ®Šèƒ½åŠ›ä¸­ã‚‚é‡åŠ›é©ç”¨
                    this.vy += 0.8;
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // åœ°é¢åˆ¤å®š
                    const groundY = canvas.height - 100;
                    if (this.y + this.height >= groundY) {
                        this.y = groundY - this.height;
                        this.vy = 0;
                        const wasInAir = !this.onGround;
                        this.onGround = true;
                        
                        // ã‚¸ãƒ£ãƒ³ãƒ—æ”»æ’ƒã‹ã‚‰ã®è¿½æ’ƒã‚³ãƒ³ãƒœï¼ˆç€åœ°ç›´å¾Œï¼‰
                        if (wasInAir && this.airComboReady && !this.isAttacking && !this.isCPU) {
                            // ã‚³ãƒ³ãƒœã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å»¶é•·ï¼ˆç€åœ°å¾Œã«ã™ãæ”»æ’ƒã™ã‚Œã°ã‚³ãƒ³ãƒœç¶™ç¶šï¼‰
                            this.comboTimer = this.comboWindow;
                        } else if (this.onGround && !this.airComboReady) {
                            // åœ°é¢ã«ç€åœ°ã—ãŸã‚‰ç©ºä¸­ã‚³ãƒ³ãƒœãƒ•ãƒ©ã‚°ãƒªã‚»ãƒƒãƒˆ
                            this.jumpAttackHit = false;
                        }
                    }
                    
                    // ç”»é¢ç«¯
                    if (this.x < 0) this.x = 0;
                    if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
                    
                    this.updateInputHistory();
                    this.animFrame += this.animSpeed;
                    return;
                }
                
                // æ”»æ’ƒ
                if (keys[this.controls.punch] && !this.isAttacking) {
                    // Graniteã®æŠ•ã’æŠ€: è¿‘è·é›¢ã§ä¸‹+ãƒ‘ãƒ³ãƒåŒæ™‚æŠ¼ã—
                    if (this.charType === 'granite' && keys[this.controls.down] && this.onGround) {
                        const opponent = this === player1 ? player2 : player1;
                        const distance = Math.abs(this.x - opponent.x);
                        if (distance < 50 && !opponent.isAttacking && opponent.stunned === 0) {
                            this.startSpecialAbility('throw');
                            return;
                        }
                    }
                    
                    // ã‚¸ãƒ£ãƒ³ãƒ—æ”»æ’ƒã‹ã‚‰ã®è¿½æ’ƒã‚³ãƒ³ãƒœåˆ¤å®š
                    if (this.airComboReady && this.onGround && this.comboTimer > 0) {
                        // ã‚³ãƒ³ãƒœç¶™ç¶š
                        this.airComboReady = false;
                    }
                    
                    playPunchSound();
                    this.startAttack('punch');
                }
                if (keys[this.controls.kick] && !this.isAttacking) {
                    // ã‚¸ãƒ£ãƒ³ãƒ—æ”»æ’ƒã‹ã‚‰ã®è¿½æ’ƒã‚³ãƒ³ãƒœåˆ¤å®š
                    if (this.airComboReady && this.onGround && this.comboTimer > 0) {
                        // ã‚³ãƒ³ãƒœç¶™ç¶š
                        this.airComboReady = false;
                    }
                    
                    playKickSound();
                    this.startAttack('kick');
                }
                if (keys[this.controls.special] && !this.isAttacking) {
                    // Universalã®ç·Šæ€¥å›é¿: ç‰¹æ®Šã‚­ãƒ¼+å¾Œã‚æ–¹å‘
                    if (this.charType === 'universal') {
                        const backKey = this.facing === 1 ? this.controls.left : this.controls.right;
                        if (keys[backKey]) {
                            this.startSpecialAbility('evade');
                            return;
                        }
                    }
                    // ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›ã§ã®å¿…æ®ºæŠ€ç™ºå‹•ã¯updateInputHistoryå†…ã§å‡¦ç†ã•ã‚Œã‚‹
                    // å˜ç´”ãªspecialã‚­ãƒ¼æŠ¼ä¸‹ã§ã®å¿…æ®ºæŠ€ã¯å»ƒæ­¢ï¼ˆã‚³ãƒãƒ³ãƒ‰å¿…é ˆï¼‰
                }
                
                // Mystiaã®æŠ±æ“æŠ€: è¿‘è·é›¢ã§ä¸Š+ã‚­ãƒƒã‚¯åŒæ™‚æŠ¼ã—
                if (this.charType === 'mystia' && keys[this.controls.kick] && keys[this.controls.up] && !this.isAttacking && this.onGround) {
                    const opponent = this === player1 ? player2 : player1;
                    const distance = Math.abs(this.x - opponent.x);
                    if (distance < 60 && !opponent.isAttacking && opponent.stunned === 0) {
                        this.startSpecialAbility('hug');
                        return;
                    }
                }
                
                // é‡åŠ›
                this.vy += 0.8;
                
                // ä½ç½®æ›´æ–°
                this.x += this.vx;
                this.y += this.vy;
                
                // åœ°é¢åˆ¤å®š
                const groundY = canvas.height - 100;
                if (this.y + this.height >= groundY) {
                    this.y = groundY - this.height;
                    this.vy = 0;
                    const wasInAir = !this.onGround;
                    this.onGround = true;
                    
                    // ã‚¸ãƒ£ãƒ³ãƒ—æ”»æ’ƒã‹ã‚‰ã®è¿½æ’ƒã‚³ãƒ³ãƒœï¼ˆç€åœ°ç›´å¾Œï¼‰
                    if (wasInAir && this.airComboReady && !this.isAttacking && !this.isCPU) {
                        // ã‚³ãƒ³ãƒœã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å»¶é•·ï¼ˆç€åœ°å¾Œã«ã™ãæ”»æ’ƒã™ã‚Œã°ã‚³ãƒ³ãƒœç¶™ç¶šï¼‰
                        this.comboTimer = this.comboWindow;
                    } else if (this.onGround && !this.airComboReady) {
                        // åœ°é¢ã«ç€åœ°ã—ãŸã‚‰ç©ºä¸­ã‚³ãƒ³ãƒœãƒ•ãƒ©ã‚°ãƒªã‚»ãƒƒãƒˆ
                        this.jumpAttackHit = false;
                    }
                }
                
                // ç”»é¢ç«¯
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
                
                // å…¥åŠ›å±¥æ­´ã®ç®¡ç†
                this.updateInputHistory();
                
                // ã‚³ãƒãƒ³ãƒ‰åˆ¤å®šï¼ˆæ”»æ’ƒä¸­ã§ãªã„æ™‚ã®ã¿ï¼‰
                if (!this.isAttacking && !this.specialAbilityActive && !this.superMoveActive) {
                    // è¶…å¿…æ®ºæŠ€ã‚³ãƒãƒ³ãƒ‰ãƒã‚§ãƒƒã‚¯
                    if (this.checkSuperMoveCommand()) {
                        this.executeSuperMove();
                    } else {
                        // é€šå¸¸å¿…æ®ºæŠ€ã‚³ãƒãƒ³ãƒ‰ãƒã‚§ãƒƒã‚¯
                        const command = this.checkCommand();
                        if (command) {
                            this.executeSpecialMove(command);
                        }
                    }
                }
                
                // å¿…æ®ºæŠ€åè¡¨ç¤ºæ™‚é–“ã®æ›´æ–°
                if (this.specialMoveNameFrames > 0) {
                    this.specialMoveNameFrames--;
                }
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                this.animFrame += this.animSpeed;
            }
            
            updateInputHistory() {
                // ç¾åœ¨ã®å…¥åŠ›çŠ¶æ…‹ã‚’è¨˜éŒ²
                const currentInput = {
                    left: keys[this.controls.left] || false,
                    right: keys[this.controls.right] || false,
                    up: keys[this.controls.up] || false,
                    down: keys[this.controls.down] || false,
                    punch: keys[this.controls.punch] || false,
                    kick: keys[this.controls.kick] || false,
                    special: keys[this.controls.special] || false
                };
                
                // å…¥åŠ›å±¥æ­´ã«è¿½åŠ ï¼ˆæœ€å¤§20ãƒ•ãƒ¬ãƒ¼ãƒ åˆ†ï¼‰
                this.inputHistory.push({ input: currentInput, frame: 0 });
                if (this.inputHistory.length > this.inputBufferTime) {
                    this.inputHistory.shift();
                }
                
                // ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã‚’æ›´æ–°
                this.inputHistory.forEach(item => item.frame++);
                
                // å¤ã„å…¥åŠ›å±¥æ­´ã‚’å‰Šé™¤
                this.inputHistory = this.inputHistory.filter(item => item.frame < this.inputBufferTime);
            }
            
            checkCommand() {
                // å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å¿…æ®ºæŠ€ã‚³ãƒãƒ³ãƒ‰å®šç¾©
                const commands = this.getSpecialMoveCommands();
                
                // å…¥åŠ›å±¥æ­´ã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ã‚’åˆ¤å®š
                for (const cmd of commands) {
                    if (this.matchCommand(cmd.sequence, cmd.button)) {
                        return cmd.name;
                    }
                }
                
                return null;
            }
            
            getSpecialMoveCommands() {
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã”ã¨ã®å¿…æ®ºæŠ€ã‚³ãƒãƒ³ãƒ‰å®šç¾©
                const facing = this.facing;
                const forward = facing === 1 ? 'right' : 'left';
                const back = facing === 1 ? 'left' : 'right';
                
                switch(this.charType) {
                    case 'ash':
                        return [
                            { sequence: ['down', forward, 'punch'], name: 'ultimate_impact' },
                            { sequence: [forward, 'down', forward, 'punch'], name: 'ultimate_impact' }
                        ];
                    case 'cyberK':
                        return [
                            { sequence: ['down', forward, 'kick'], name: 'middle_kick' },
                            { sequence: [forward, 'down', forward, 'kick'], name: 'middle_kick' }
                        ];
                    case 'granite':
                        return [
                            { sequence: ['down', 'down', forward, 'punch'], name: 'granite_press' },
                            { sequence: [forward, 'down', 'down', forward, 'punch'], name: 'granite_press' }
                        ];
                    case 'mystia':
                        return [
                            { sequence: ['down', forward, 'kick'], name: 'mujihi_hoyo' },
                            { sequence: ['up', forward, 'kick'], name: 'mujihi_hoyo' }
                        ];
                    case 'zen':
                        return [
                            { sequence: ['down', back, 'punch'], name: 'kuusemi_gaashi' },
                            { sequence: [back, 'down', back, 'punch'], name: 'kuusemi_gaashi' }
                        ];
                    case 'universal':
                        return [
                            { sequence: ['down', forward, 'special'], name: 'emergency_step' },
                            { sequence: [forward, back, forward, 'special'], name: 'emergency_step' }
                        ];
                    default:
                        return [];
                }
            }
            
            checkSuperMoveCommand() {
                // ã‚²ãƒ¼ã‚¸ãŒè¶³ã‚Šãªã„å ´åˆã¯ç™ºå‹•ä¸å¯
                const charData = characterData[this.charType];
                if (!charData.superMove) return false;
                if (this.superGauge < charData.superMove.gaugeCost) return false;
                
                // è¶…å¿…æ®ºæŠ€ã‚³ãƒãƒ³ãƒ‰åˆ¤å®š
                const command = charData.superMove.command;
                const facing = this.facing;
                const forward = facing === 1 ? 'right' : 'left';
                const back = facing === 1 ? 'left' : 'right';
                
                // ã‚³ãƒãƒ³ãƒ‰ã‚’å‘ãã«å¿œã˜ã¦å¤‰æ›
                const normalizedCommand = command.map(cmd => {
                    if (cmd === 'forward') return forward;
                    if (cmd === 'back') return back;
                    return cmd;
                });
                
                // ãƒœã‚¿ãƒ³ã¯æœ€å¾Œã®è¦ç´ 
                const button = normalizedCommand[normalizedCommand.length - 1];
                const sequence = normalizedCommand.slice(0, -1);
                
                if (this.matchCommand(sequence, button)) {
                    return true;
                }
                
                return false;
            }
            
            matchCommand(sequence, button) {
                // å…¥åŠ›å±¥æ­´ã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ãƒãƒƒãƒãƒ³ã‚°
                if (this.inputHistory.length < sequence.length) return false;
                
                // ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€æ–°ã®æ•°ãƒ•ãƒ¬ãƒ¼ãƒ å†…ï¼‰
                const recentFrames = 5;
                let buttonPressed = false;
                for (let i = 0; i < recentFrames && i < this.inputHistory.length; i++) {
                    const input = this.inputHistory[this.inputHistory.length - 1 - i].input;
                    if (button === 'punch' && input.punch) buttonPressed = true;
                    if (button === 'kick' && input.kick) buttonPressed = true;
                    if (button === 'special' && input.special) buttonPressed = true;
                }
                if (!buttonPressed) return false;
                
                // ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’é€†é †ã§ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€æ–°ã®å…¥åŠ›ã‹ã‚‰ï¼‰
                let seqIndex = sequence.length - 1;
                let lastFoundFrame = -1;
                const forward = this.facing === 1 ? 'right' : 'left';
                const back = this.facing === 1 ? 'left' : 'right';
                
                for (let i = this.inputHistory.length - 1; i >= 0 && seqIndex >= 0; i--) {
                    const item = this.inputHistory[i];
                    const input = item.input;
                    
                    // ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸæ™‚ç‚¹ã®å…¥åŠ›ã¯ã‚¹ã‚­ãƒƒãƒ—
                    if (item.frame === 0) {
                        if ((button === 'punch' && input.punch) || 
                            (button === 'kick' && input.kick) || 
                            (button === 'special' && input.special)) {
                            continue;
                        }
                    }
                    
                    // æ–¹å‘å…¥åŠ›ã®åˆ¤å®š
                    let direction = null;
                    // å˜ç´”ãªæ–¹å‘å…¥åŠ›
                    if (input.left && !input.right && !input.up && !input.down) direction = 'left';
                    if (input.right && !input.left && !input.up && !input.down) direction = 'right';
                    if (input.up && !input.down && !input.left && !input.right) direction = 'up';
                    if (input.down && !input.up && !input.left && !input.right) direction = 'down';
                    
                    // forward/backã‚’å®Ÿéš›ã®å‘ãã«å¤‰æ›
                    let actualDirection = direction;
                    if (direction === 'left') actualDirection = back;
                    if (direction === 'right') actualDirection = forward;
                    
                    if (actualDirection === sequence[seqIndex] || direction === sequence[seqIndex]) {
                        if (lastFoundFrame === -1 || item.frame < lastFoundFrame) {
                            lastFoundFrame = item.frame;
                            seqIndex--;
                        }
                    }
                }
                
                return seqIndex < 0; // ã™ã¹ã¦ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒè¦‹ã¤ã‹ã£ãŸ
            }
            
            executeSpecialMove(moveName) {
                // å¿…æ®ºæŠ€ã‚’ç™ºå‹•
                this.specialMoveName = moveName;
                this.specialMoveNameFrames = 60; // 1ç§’é–“è¡¨ç¤º
                this.startAttack('special');
                this.inputHistory = []; // å…¥åŠ›å±¥æ­´ã‚’ã‚¯ãƒªã‚¢
                playSpecialSound(this.charType);
            }
            
            executeSuperMove() {
                // è¶…å¿…æ®ºæŠ€ã‚’ç™ºå‹•
                const charData = characterData[this.charType];
                if (!charData.superMove) return;
                
                // ã‚²ãƒ¼ã‚¸æ¶ˆè²»
                this.superGauge -= charData.superMove.gaugeCost;
                
                // è¶…å¿…æ®ºæŠ€ç™ºå‹•
                this.superMoveActive = true;
                this.superMoveFrame = 0;
                this.superMoveName = charData.superMove.name;
                this.isAttacking = true;
                this.attackType = 'super';
                this.attackFrame = 0;
                this.vx = 0; // ç§»å‹•åœæ­¢
                
                // å…¥åŠ›å±¥æ­´ã‚’ã‚¯ãƒªã‚¢
                this.inputHistory = [];
                
                // æ¼”å‡ºé–‹å§‹
                playSuperMoveSound(this.charType);
                shakeCamera(15, 30);
                startSlowMotion(0.3, 40);
                
                // ç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
                createScreenFlash(this.color);
            }
            
            updateCPU() {
                const opponent = this === player1 ? player2 : player1;
                const distance = Math.abs(this.x - opponent.x);
                const heightDiff = Math.abs(this.y - opponent.y);
                
                // AIåå¿œæ™‚é–“ã¨ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã®æ›´æ–°
                if (this.aiReactionTime > 0) {
                    this.aiReactionTime--;
                }
                
                if (this.aiActionCooldown > 0) {
                    this.aiActionCooldown--;
                }
                
                // ç›¸æ‰‹ã®å‘ãã‚’ç¢ºèªï¼ˆCPUã¯å¸¸ã«ç›¸æ‰‹ã®æ–¹ã‚’å‘ãï¼‰
                if (opponent.x < this.x) {
                    this.facing = -1;
                } else {
                    this.facing = 1;
                }
                
                // CPUã®ã‚­ãƒ¼å…¥åŠ›ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
                keys[this.controls.left] = false;
                keys[this.controls.right] = false;
                keys[this.controls.up] = false;
                keys[this.controls.down] = false;
                keys[this.controls.punch] = false;
                keys[this.controls.kick] = false;
                
                // åå¿œæ™‚é–“ä¸­ã‚„ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã¯è¡Œå‹•ã—ãªã„
                if (this.aiReactionTime > 0 || this.aiActionCooldown > 0) {
                    return;
                }
                
                // ã‚¹ã‚¿ãƒ³ä¸­ã‚„æ”»æ’ƒä¸­ã¯è¡Œå‹•ã—ãªã„
                if (this.stunned > 0 || this.isAttacking || this.specialAbilityActive) {
                    return;
                }
                
                // è·é›¢ã«å¿œã˜ãŸè¡Œå‹•é¸æŠ
                const isOpponentAttacking = opponent.isAttacking || opponent.specialAbilityActive;
                const isOpponentRecovering = opponent.isAttacking && opponent.attackFrame > (opponent.attacks[opponent.attackType]?.startup || 0) + 5;
                
                if (distance > 250) {
                    // é è·é›¢ï¼šæ¥è¿‘
                    this.aiState = 'approach';
                } else if (distance < 90 && !isOpponentAttacking && this.onGround) {
                    // è¿‘è·é›¢ï¼šæ”»æ’ƒãƒãƒ£ãƒ³ã‚¹
                    this.aiState = 'attack';
                } else if (isOpponentAttacking && distance < 120) {
                    // ç›¸æ‰‹ãŒæ”»æ’ƒä¸­ï¼šé˜²å¾¡
                    this.aiState = 'defend';
                } else if (distance < 70 && opponent.comboCount > 2) {
                    // ç›¸æ‰‹ãŒã‚³ãƒ³ãƒœä¸­ï¼šå¾Œé€€
                    this.aiState = 'retreat';
                } else if (distance < 100 && !this.onGround && !this.isAttacking) {
                    // ç©ºä¸­ã«ã„ã‚‹æ™‚ï¼šç©ºä¸­æ”»æ’ƒ
                    this.aiState = 'air_attack';
                } else {
                    this.aiState = 'idle';
                }
                
                // è¡Œå‹•ã®å®Ÿè¡Œ
                switch(this.aiState) {
                    case 'approach':
                        // æ¥è¿‘
                        if (opponent.x > this.x) {
                            keys[this.controls.right] = true;
                        } else {
                            keys[this.controls.left] = true;
                        }
                        
                        // ãŸã¾ã«ã‚¸ãƒ£ãƒ³ãƒ—ã§æ¥è¿‘ï¼ˆ10%ã®ç¢ºç‡ï¼‰
                        if (Math.random() < 0.1 && this.onGround) {
                            keys[this.controls.up] = true;
                            this.aiReactionTime = 5;
                        }
                        this.aiActionCooldown = 5 + Math.floor(Math.random() * 5);
                        break;
                        
                    case 'attack':
                        // æ”»æ’ƒ
                        const attackRand = Math.random();
                        const healthRatio = this.health / this.maxHealth;
                        
                        // ä½“åŠ›ãŒå°‘ãªã„æ™‚ã¯å¿…æ®ºæŠ€ã‚’ä½¿ã„ã‚„ã™ã„
                        if (attackRand < 0.35 && !this.isAttacking) {
                            // ãƒ‘ãƒ³ãƒ
                            keys[this.controls.punch] = true;
                            this.aiActionCooldown = 15 + Math.floor(Math.random() * 10);
                            this.aiReactionTime = 3 + Math.floor(Math.random() * 3);
                        } else if (attackRand < 0.65 && !this.isAttacking) {
                            // ã‚­ãƒƒã‚¯
                            keys[this.controls.kick] = true;
                            this.aiActionCooldown = 20 + Math.floor(Math.random() * 10);
                            this.aiReactionTime = 3 + Math.floor(Math.random() * 3);
                        } else if (attackRand < 0.8 && !this.isAttacking && healthRatio < 0.5 && Math.random() < 0.4) {
                            // å¿…æ®ºæŠ€ï¼ˆä½“åŠ›ãŒ50%ä»¥ä¸‹ã§40%ã®ç¢ºç‡ï¼‰
                            this.executeSpecialMove(this.getRandomSpecialMove());
                            this.aiActionCooldown = 30 + Math.floor(Math.random() * 15);
                            this.aiReactionTime = 5;
                        } else if (!this.onGround && !this.isAttacking) {
                            // ç©ºä¸­æ”»æ’ƒ
                            keys[this.controls.punch] = true;
                            this.aiActionCooldown = 12 + Math.floor(Math.random() * 8);
                            this.aiReactionTime = 2;
                        } else {
                            // ç§»å‹•ã—ãªãŒã‚‰æ”»æ’ƒæº–å‚™
                            if (distance > 60 && opponent.x > this.x) {
                                keys[this.controls.right] = true;
                            } else if (distance > 60 && opponent.x < this.x) {
                                keys[this.controls.left] = true;
                            }
                            this.aiActionCooldown = 8 + Math.floor(Math.random() * 5);
                        }
                        break;
                        
                    case 'defend':
                        // é˜²å¾¡
                        const guardChance = 0.8; // 80%ã®ç¢ºç‡ã§ã‚¬ãƒ¼ãƒ‰
                        if (Math.random() < guardChance) {
                            keys[this.controls.down] = true;
                            this.aiActionCooldown = 15 + Math.floor(Math.random() * 10);
                            this.aiReactionTime = 3 + Math.floor(Math.random() * 3);
                        } else {
                            // ã‚¬ãƒ¼ãƒ‰ã—ãªã‹ã£ãŸå ´åˆã€å¾Œé€€
                            if (opponent.x > this.x) {
                                keys[this.controls.left] = true;
                            } else {
                                keys[this.controls.right] = true;
                            }
                            this.aiActionCooldown = 10;
                        }
                        
                        // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã®å¯èƒ½æ€§ï¼ˆZenã®å ´åˆã¯é«˜ç¢ºç‡ï¼‰
                        if (isOpponentRecovering && distance < 100 && !this.isAttacking) {
                            if (this.charType === 'zen' && Math.random() < 0.5) {
                                // Zenã¯é«˜ç¢ºç‡ã§ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
                                keys[this.controls.kick] = true;
                                this.aiActionCooldown = 12;
                                this.aiReactionTime = 2;
                            } else if (Math.random() < 0.25) {
                                // ãã®ä»–ã®ã‚­ãƒ£ãƒ©ã¯25%ã®ç¢ºç‡
                                keys[this.controls.punch] = true;
                                this.aiActionCooldown = 12;
                                this.aiReactionTime = 3;
                            }
                        }
                        break;
                        
                    case 'retreat':
                        // å¾Œé€€
                        if (opponent.x > this.x) {
                            keys[this.controls.left] = true;
                        } else {
                            keys[this.controls.right] = true;
                        }
                        
                        // ã‚¸ãƒ£ãƒ³ãƒ—ã§å›é¿ï¼ˆ30%ã®ç¢ºç‡ï¼‰
                        if (Math.random() < 0.3 && this.onGround) {
                            keys[this.controls.up] = true;
                            this.aiReactionTime = 5;
                        }
                        this.aiActionCooldown = 12 + Math.floor(Math.random() * 8);
                        break;
                        
                    case 'air_attack':
                        // ç©ºä¸­æ”»æ’ƒ
                        if (!this.isAttacking) {
                            keys[this.controls.punch] = true;
                            this.aiActionCooldown = 10 + Math.floor(Math.random() * 5);
                            this.aiReactionTime = 2;
                        }
                        break;
                        
                    case 'idle':
                        // å¾…æ©Ÿï¼ˆãŸã¾ã«ç§»å‹•ï¼‰
                        if (Math.random() < 0.15) {
                            if (distance > 150) {
                                // é ã„æ™‚ã¯æ¥è¿‘
                                if (opponent.x > this.x) {
                                    keys[this.controls.right] = true;
                                } else {
                                    keys[this.controls.left] = true;
                                }
                            } else if (distance < 80) {
                                // è¿‘ã„æ™‚ã¯å¾Œé€€
                                if (opponent.x > this.x) {
                                    keys[this.controls.left] = true;
                                } else {
                                    keys[this.controls.right] = true;
                                }
                            }
                            this.aiActionCooldown = 8 + Math.floor(Math.random() * 5);
                        } else {
                            this.aiActionCooldown = 10 + Math.floor(Math.random() * 10);
                        }
                        break;
                }
            }
            
            getRandomSpecialMove() {
                // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã”ã¨ã®å¿…æ®ºæŠ€åã‚’è¿”ã™
                switch(this.charType) {
                    case 'ash': return 'ultimate_impact';
                    case 'cyberK': return 'middle_kick';
                    case 'granite': return 'granite_press';
                    case 'mystia': return 'mujihi_hoyo';
                    case 'zen': return 'kuusemi_gaashi';
                    case 'universal': return 'emergency_step';
                    default: return 'ultimate_impact';
                }
            }
            
            startAttack(type) {
                this.isAttacking = true;
                this.attackType = type;
                this.attackFrame = 0;
                this.lastHitConnected = false; // æ–°ã—ã„æ”»æ’ƒé–‹å§‹æ™‚ã«ãƒªã‚»ãƒƒãƒˆ
            }
            
            canCancelAttack(attack) {
                // ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ãƒ•ãƒ¬ãƒ¼ãƒ å†…ã‹ãƒã‚§ãƒƒã‚¯
                if (!attack.cancelWindow || !this.lastHitConnected) {
                    return false;
                }
                const cancelStart = attack.startup + attack.cancelWindow.start;
                const cancelEnd = attack.startup + attack.cancelWindow.end;
                return this.attackFrame >= cancelStart && this.attackFrame <= cancelEnd;
            }
            
            checkCancelInput() {
                // å…¥åŠ›ã«å¿œã˜ã¦ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ãªæŠ€ã‚’è¿”ã™
                const attack = this.attacks[this.attackType];
                if (!attack.cancellableInto) return null;
                
                // ã‚¬ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥å¾Œã®ç¢ºå®šã‚³ãƒ³ãƒœã¯å¿…æ®ºæŠ€ã«ã‚‚ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½
                if (this.guardCrushComboReady && keys[this.controls.special]) {
                    // ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›ãƒã‚§ãƒƒã‚¯
                    const command = this.checkCommand();
                    if (command) {
                        this.guardCrushComboReady = false; // ä½¿ç”¨æ¸ˆã¿
                        return null; // executeSpecialMoveãŒå‘¼ã°ã‚Œã‚‹
                    }
                }
                
                // é€šå¸¸ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«å…¥åŠ›ãƒã‚§ãƒƒã‚¯
                for (const cancelType of attack.cancellableInto) {
                    if (cancelType === 'kick' && keys[this.controls.kick]) {
                        return 'kick';
                    } else if (cancelType === 'punch' && keys[this.controls.punch]) {
                        return 'punch';
                    } else if (cancelType === 'special' && keys[this.controls.special]) {
                        // å¿…æ®ºæŠ€ã¯ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›ãŒå¿…è¦
                        const command = this.checkCommand();
                        if (command) {
                            return null; // executeSpecialMoveãŒå‘¼ã°ã‚Œã‚‹
                        }
                    }
                }
                return null;
            }
            
            startSpecialAbility(type) {
                this.specialAbilityActive = true;
                this.specialAbilityType = type;
                this.specialAbilityFrame = 0;
                this.vx = 0; // ç§»å‹•ã‚’åœæ­¢
            }
            
            updateSpecialAbility() {
                this.specialAbilityFrame++;
                const opponent = this === player1 ? player2 : player1;
                
                switch (this.specialAbilityType) {
                    case 'throw': // Graniteã®æŠ•ã’æŠ€
                        if (this.specialAbilityFrame === 10) {
                            // æŠ•ã’æŠ€ç™ºå‹•
                            const distance = Math.abs(this.x - opponent.x);
                            if (distance < 60) {
                                const throwDamage = 35;
                                opponent.health -= throwDamage; // é«˜ãƒ€ãƒ¡ãƒ¼ã‚¸
                                if (opponent.health < 0) opponent.health = 0;
                                opponent.x += this.facing * 50; // å¤§ãããƒãƒƒã‚¯ãƒãƒƒã‚¯
                                opponent.y -= 20; // æµ®ã‹ã›ã‚‹
                                opponent.vy = -8;
                                opponent.stunned = 40; // é•·ã„ã‚¹ã‚¿ãƒ³
                                
                                // ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å­—
                                damageNumbers.push(new DamageNumber(
                                    opponent.x + opponent.width / 2,
                                    opponent.y + 30,
                                    throwDamage,
                                    true, // æŠ•ã’æŠ€ã¯ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«
                                    1
                                ));
                                
                                // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯ã¨ã‚¹ãƒ­ãƒ¼ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³
                                shakeCamera(12, 18);
                                startSlowMotion(0.4, 25);
                                
                                // æŠ•ã’ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                                for (let i = 0; i < 40; i++) {
                                    particles.push(new Particle(opponent.x, opponent.y + 40, '#888'));
                                }
                            }
                        }
                        if (this.specialAbilityFrame >= 40) {
                            this.specialAbilityActive = false;
                            this.specialAbilityType = null;
                        }
                        break;
                        
                    case 'evade': // Universalã®ç·Šæ€¥å›é¿
                        if (this.specialAbilityFrame === 1) {
                            // ãƒãƒƒã‚¯ã‚¹ãƒ†ãƒƒãƒ—
                            this.vx = -this.facing * 15;
                            this.invincible = 20; // ç„¡æ•µæ™‚é–“
                            this.evadeFrames = 20;
                        }
                        if (this.specialAbilityFrame >= 15) {
                            this.specialAbilityActive = false;
                            this.specialAbilityType = null;
                            this.vx = 0;
                        }
                        if (this.evadeFrames > 0) {
                            this.evadeFrames--;
                        }
                        break;
                        
                    case 'hug': // Mystiaã®æŠ±æ“æŠ€
                        if (this.specialAbilityFrame === 8) {
                            const distance = Math.abs(this.x - opponent.x);
                            if (distance < 70) {
                                const hugDamage = 20;
                                opponent.health -= hugDamage;
                                if (opponent.health < 0) opponent.health = 0;
                                opponent.stunned = 25;
                                
                                // ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å­—
                                damageNumbers.push(new DamageNumber(
                                    (this.x + opponent.x) / 2,
                                    (this.y + opponent.y) / 2 - 20,
                                    hugDamage,
                                    false,
                                    1
                                ));
                                
                                // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯
                                shakeCamera(6, 10);
                                
                                // æŠ±æ“ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                                for (let i = 0; i < 30; i++) {
                                    particles.push(new Particle((this.x + opponent.x) / 2, (this.y + opponent.y) / 2, '#f4f'));
                                }
                            }
                        }
                        if (this.specialAbilityFrame >= 30) {
                            this.specialAbilityActive = false;
                            this.specialAbilityType = null;
                        }
                        break;
                }
            }
            
            performAttack() {
                const attack = this.attacks[this.attackType];
                const opponent = this === player1 ? player2 : player1;
                
                const distance = Math.abs(this.x - opponent.x);
                const attackReach = attack.range;
                
                // æ”»æ’ƒåˆ¤å®šï¼ˆå‘ãåˆ¤å®šã‚‚å«ã‚€ï¼‰
                const isFacingOpponent = (this.x < opponent.x && this.facing === 1) || 
                                         (this.x > opponent.x && this.facing === -1);
                
                let hitResult = { hit: false };
                
                if (distance < attackReach && 
                    Math.abs(this.y - opponent.y) < 50 &&
                    opponent.invincible === 0) {
                    
                    hitResult.hit = true;
                    
                    let damage = attack.damage;
                    let hitType = 'normal'; // 'guard', 'normal', 'back'
                    let hitStopFrames = 0;
                    
                    // å‘ãåˆ¤å®šï¼šèƒŒé¢æ”»æ’ƒã§ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ 
                    const isBackAttack = !isFacingOpponent;
                    if (isBackAttack) {
                        damage *= 1.5; // èƒŒé¢æ”»æ’ƒã¯1.5å€
                        hitType = 'back';
                    }
                    
                    // ã‚¬ãƒ¼ãƒ‰åˆ¤å®š
                    const isGuarding = opponent.isBlocking && !opponent.guardCrushed && 
                                       ((opponent.x < this.x && opponent.facing === 1) || 
                                        (opponent.x > this.x && opponent.facing === -1));
                    
                    if (isGuarding) {
                        // ã‚¬ãƒ¼ãƒ‰æˆåŠŸ
                        damage *= 0.3;
                        hitType = 'guard';
                        
                        // ã‚¬ãƒ¼ãƒ‰ã‚²ãƒ¼ã‚¸æ¸›å°‘
                        const guardDamage = attack.damage * 0.15; // ã‚¬ãƒ¼ãƒ‰ã§ã‚‚ã‚²ãƒ¼ã‚¸ãƒ€ãƒ¡ãƒ¼ã‚¸
                        opponent.guardGauge -= guardDamage;
                        if (opponent.guardGauge < 0) {
                            opponent.guardGauge = 0;
                            opponent.guardCrushed = true;
                            opponent.guardCrushedTime = 120; // 2ç§’é–“ã‚¬ãƒ¼ãƒ‰ä¸å¯
                            opponent.stunned = 30; // ã‚¬ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥æ™‚ã¯ã‚¹ã‚¿ãƒ³
                            hitType = 'guardCrush';
                            playGuardCrushSound();
                            // ã‚¬ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥å¾Œã¯ç¢ºå®šã‚³ãƒ³ãƒœå¯èƒ½
                            this.guardCrushComboReady = true;
                            this.lastHitConnected = true;
                        } else {
                            playGuardSound();
                        }
                        
                        // è¶…å¿…æ®ºæŠ€ã‚²ãƒ¼ã‚¸å¢—åŠ ï¼ˆã‚¬ãƒ¼ãƒ‰æ™‚ï¼‰
                        this.superGauge = Math.min(this.maxSuperGauge, this.superGauge + this.superGaugeGainOnBlock);
                        
                        this.createParticles(opponent.x, opponent.y + 40, '#ff0', 5);
                        hitStopFrames = 3; // ã‚¬ãƒ¼ãƒ‰æ™‚ã¯è»½ã„ãƒ’ãƒƒãƒˆã‚¹ãƒˆãƒƒãƒ—
                    } else {
                        // é€šå¸¸ãƒ’ãƒƒãƒˆ
                        opponent.stunned = this.getStunFrames(attack);
                        this.createParticles(opponent.x, opponent.y + 40, '#f44', 10);
                        
                        // ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã¯performAttack()ã®æˆ»ã‚Šå€¤ã§è¨­å®šã•ã‚Œã‚‹ï¼ˆå‘¼ã³å‡ºã—å´ã§å‡¦ç†ï¼‰
                        
                        // ã‚¸ãƒ£ãƒ³ãƒ—æ”»æ’ƒã®åˆ¤å®š
                        if (!this.onGround && (this.attackType === 'punch' || this.attackType === 'kick')) {
                            this.jumpAttackHit = true;
                            this.airComboReady = true; // ç€åœ°å¾Œã«è¿½æ’ƒå¯èƒ½
                            opponent.vy = -5; // å°‘ã—æµ®ã‹ã›ã‚‹ï¼ˆè¿½æ’ƒã—ã‚„ã™ãã™ã‚‹ï¼‰
                        }
                        
                        // ã‚¬ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥å¾Œã®ç¢ºå®šã‚³ãƒ³ãƒœå¯èƒ½çŠ¶æ…‹
                        if (opponent.guardCrushed) {
                            this.guardCrushComboReady = true;
                        }
                        
                        // ãƒ’ãƒƒãƒˆæ™‚ã«ç›¸æ‰‹ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                        if (opponent.charType === 'zen') {
                            opponent.counterReady = false;
                        }
                        
                        // ã‚³ãƒ³ãƒœã‚·ã‚¹ãƒ†ãƒ 
                        if (this.comboTimer > 0) {
                            // ã‚³ãƒ³ãƒœã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å†…ãªã‚‰ã‚³ãƒ³ãƒœç¶™ç¶š
                            this.comboCount++;
                            this.comboTimer = this.comboWindow;
                        } else {
                            // æ–°è¦ã‚³ãƒ³ãƒœé–‹å§‹
                            this.comboCount = 1;
                            this.comboTimer = this.comboWindow;
                        }
                        
                        // ã‚³ãƒ³ãƒœã«ã‚ˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸å€ç‡
                        const comboMultiplier = 1 + (this.comboCount - 1) * 0.1; // 2ãƒ’ãƒƒãƒˆç›®ã‹ã‚‰10%ãšã¤å¢—åŠ 
                        damage *= Math.min(comboMultiplier, 2.0); // æœ€å¤§2å€
                        
                        // è¶…å¿…æ®ºæŠ€ã‚²ãƒ¼ã‚¸å¢—åŠ ï¼ˆæ”»æ’ƒå‘½ä¸­æ™‚ï¼‰
                        this.superGauge = Math.min(this.maxSuperGauge, this.superGauge + this.superGaugeGainOnHit);
                        
                        // ãƒ’ãƒƒãƒˆã‚¹ãƒˆãƒƒãƒ—ã®è¨ˆç®—ï¼ˆæ”»æ’ƒã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ï¼‰
                        hitStopFrames = this.getHitStopFrames(attack);
                        
                        // ç›¸æ‰‹ã®ã‚³ãƒ³ãƒœã‚’ãƒªã‚»ãƒƒãƒˆ
                        opponent.comboCount = 0;
                        opponent.comboTimer = 0;
                    }
                    
                    opponent.health -= damage;
                    if (opponent.health < 0) opponent.health = 0;
                    
                    // è¶…å¿…æ®ºæŠ€ã‚²ãƒ¼ã‚¸å¢—åŠ ï¼ˆè¢«å¼¾æ™‚ï¼‰
                    opponent.superGauge = Math.min(opponent.maxSuperGauge, opponent.superGauge + opponent.superGaugeGainOnDamage);
                    
                    // ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å­—ã‚’è¡¨ç¤º
                    const isCritical = hitType === 'back' || damage >= 20 || this.comboCount >= 5;
                    damageNumbers.push(new DamageNumber(
                        opponent.x + opponent.width / 2,
                        opponent.y + 30,
                        damage,
                        isCritical,
                        this.comboCount
                    ));
                    
                    // ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
                    if (isCritical) {
                        criticalTexts.push(new CriticalText(
                            opponent.x + opponent.width / 2,
                            opponent.y,
                            'CRITICAL!'
                        ));
                    }
                    
                    // ãƒ’ãƒƒãƒˆéŸ³å†ç”Ÿ
                    playHitSound(isCritical);
                    
                    // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯
                    if (hitType === 'guardCrush') {
                        shakeCamera(15, 20);
                        startSlowMotion(0.3, 30); // ã‚¬ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥æ™‚ã¯ã‚¹ãƒ­ãƒ¼ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³
                    } else if (hitType === 'back' || damage >= 25) {
                        shakeCamera(10, 15);
                        startSlowMotion(0.5, 20);
                    } else if (this.attackType === 'special') {
                        shakeCamera(8, 12);
                        startSlowMotion(0.6, 15);
                    } else if (damage >= 15) {
                        shakeCamera(5, 8);
                    } else {
                        shakeCamera(3, 5);
                    }
                    
                    // ãƒãƒƒã‚¯ãƒãƒƒã‚¯ï¼ˆæ”»æ’ƒã‚¿ã‚¤ãƒ—ã¨ãƒ’ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ï¼‰
                    const knockbackX = this.getKnockbackX(attack, hitType);
                    const knockbackY = this.getKnockbackY(attack, hitType);
                    opponent.x += this.facing * knockbackX;
                    opponent.vy = knockbackY;
                    
                    // ãƒ’ãƒƒãƒˆã‚¹ãƒˆãƒƒãƒ—é©ç”¨
                    if (hitStopFrames > 0 && hitType !== 'guard') {
                        player1.hitStopActive = true;
                        player1.hitStopFrames = hitStopFrames;
                        player2.hitStopActive = true;
                        player2.hitStopFrames = hitStopFrames;
                    }
                    
                    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆè¦–è¦šçš„è¡¨ç¾ï¼‰
                    if (this.attackType === 'special') {
                        this.createSpecialEffect(opponent, hitType);
                    } else if (hitType === 'back') {
                        this.createParticles(opponent.x, opponent.y + 40, '#f0f', 15); // èƒŒé¢æ”»æ’ƒã¯ç´«ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    } else if (hitType === 'guardCrush') {
                        this.createParticles(opponent.x, opponent.y + 40, '#f00', 20); // ã‚¬ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã¯èµ¤ã„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    }
                }
                
                return hitResult;
            }
            
            performSuperMove() {
                // è¶…å¿…æ®ºæŠ€ã®æ”»æ’ƒåˆ¤å®š
                const charData = characterData[this.charType];
                const superMove = charData.superMove;
                const opponent = this === player1 ? player2 : player1;
                
                const distance = Math.abs(this.x - opponent.x);
                const attackReach = superMove.range;
                
                if (distance < attackReach && 
                    Math.abs(this.y - opponent.y) < 60 &&
                    opponent.invincible === 0) {
                    
                    let damage = superMove.damage;
                    let hitType = 'super';
                    
                    // ã‚¬ãƒ¼ãƒ‰åˆ¤å®š
                    const isGuarding = opponent.isBlocking && !opponent.guardCrushed && 
                                       ((opponent.x < this.x && opponent.facing === 1) || 
                                        (opponent.x > this.x && opponent.facing === -1));
                    
                    if (isGuarding) {
                        // ã‚¬ãƒ¼ãƒ‰æˆåŠŸï¼ˆè¶…å¿…æ®ºæŠ€ã¯ã‚¬ãƒ¼ãƒ‰æ™‚ã§ã‚‚é«˜ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
                        damage *= 0.5;
                        hitType = 'guard';
                        playGuardSound();
                    } else {
                        // é€šå¸¸ãƒ’ãƒƒãƒˆ
                        opponent.stunned = 40; // é•·ã„ã‚¹ã‚¿ãƒ³
                        this.createParticles(opponent.x, opponent.y + 40, this.color, 30);
                        
                        // ã‚³ãƒ³ãƒœã‚·ã‚¹ãƒ†ãƒ 
                        if (this.comboTimer > 0) {
                            this.comboCount++;
                            this.comboTimer = this.comboWindow;
                        } else {
                            this.comboCount = 1;
                            this.comboTimer = this.comboWindow;
                        }
                        
                        // è¶…å¿…æ®ºæŠ€ã¯å¸¸ã«ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«
                        damage *= 1.3;
                    }
                    
                    opponent.health -= damage;
                    if (opponent.health < 0) opponent.health = 0;
                    
                    // ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å­—
                    damageNumbers.push(new DamageNumber(
                        opponent.x + opponent.width / 2,
                        opponent.y + 30,
                        damage,
                        true, // å¸¸ã«ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«
                        this.comboCount
                    ));
                    
                    // è¶…å¿…æ®ºæŠ€ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
                    criticalTexts.push(new CriticalText(
                        opponent.x + opponent.width / 2,
                        opponent.y - 30,
                        this.superMoveName + '!'
                    ));
                    
                    // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯ã¨ã‚¹ãƒ­ãƒ¼ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³
                    shakeCamera(20, 40);
                    startSlowMotion(0.2, 50);
                    
                    // ãƒãƒƒã‚¯ãƒãƒƒã‚¯
                    opponent.x += this.facing * 40;
                    opponent.vy = -12;
                    
                    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    for (let i = 0; i < 60; i++) {
                        particles.push(new Particle(opponent.x, opponent.y + 40, this.color));
                    }
                    
                    // ãƒ’ãƒƒãƒˆéŸ³
                    playHitSound(true);
                }
            }
            
            getStunFrames(attack) {
                // æ”»æ’ƒã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸã‚¹ã‚¿ãƒ³æ™‚é–“
                if (attack === this.attacks.punch) return 8;
                if (attack === this.attacks.kick) return 12;
                if (attack === this.attacks.special) return 20;
                return 10;
            }
            
            getHitStopFrames(attack) {
                // æ”»æ’ƒã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸãƒ’ãƒƒãƒˆã‚¹ãƒˆãƒƒãƒ—æ™‚é–“
                if (this.attackType === 'punch') return 5;
                if (this.attackType === 'kick') return 8;
                if (this.attackType === 'special') return 12;
                return 5;
            }
            
            getKnockbackX(attack, hitType) {
                // ãƒãƒƒã‚¯ãƒãƒƒã‚¯é‡ï¼ˆXè»¸ï¼‰
                let baseKnockback = 15;
                if (this.attackType === 'punch') baseKnockback = 12;
                if (this.attackType === 'kick') baseKnockback = 18;
                if (this.attackType === 'special') baseKnockback = 25;
                
                if (hitType === 'guard') baseKnockback *= 0.5;
                if (hitType === 'back') baseKnockback *= 1.2;
                if (hitType === 'guardCrush') baseKnockback *= 1.5;
                
                return baseKnockback;
            }
            
            getKnockbackY(attack, hitType) {
                // ãƒãƒƒã‚¯ãƒãƒƒã‚¯é‡ï¼ˆYè»¸ï¼‰
                let baseKnockback = -5;
                if (this.attackType === 'kick') baseKnockback = -7;
                if (this.attackType === 'special') baseKnockback = -10;
                
                if (hitType === 'guardCrush') baseKnockback = -8;
                
                return baseKnockback;
            }
            
            createParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    particles.push(new Particle(x, y, color));
                }
            }
            
            createSpecialEffect(opponent, hitType) {
                // å¿…æ®ºæŠ€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                const effectCount = hitType === 'guardCrush' ? 50 : 30;
                for (let i = 0; i < effectCount; i++) {
                    particles.push(new Particle(opponent.x, opponent.y + 40, this.color));
                }
            }
            
            draw() {
                ctx.save();
                
                // ã‚¹ã‚¿ãƒ³æ™‚ç‚¹æ»…
                if (this.stunned > 0 && Math.floor(this.stunned / 3) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
                
                // ç„¡æ•µæ™‚ã‚ªãƒ¼ãƒ©
                if (this.invincible > 0) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.color;
                }
                
                const centerX = this.x + this.width / 2;
                const headY = this.y + 15;
                const bodyY = this.y + 45;
                const legY = this.y + this.height - 15;
                
                // é ­
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(centerX, headY, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // ä½“
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                
                // èƒ´ä½“
                ctx.beginPath();
                ctx.moveTo(centerX, headY + 15);
                ctx.lineTo(centerX, bodyY + 15);
                ctx.stroke();
                
                // ç‰¹æ®Šèƒ½åŠ›ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.specialAbilityActive) {
                    this.drawSpecialAbilityPose(centerX, headY, bodyY, legY);
                } else if (this.superMoveActive) {
                    this.drawSuperMovePose(centerX, headY, bodyY, legY);
                } else if (this.isAttacking) {
                    this.drawAttackPose(centerX, headY, bodyY, legY);
                } else if (this.isBlocking) {
                    this.drawBlockPose(centerX, headY, bodyY, legY);
                } else if (!this.onGround) {
                    this.drawJumpPose(centerX, headY, bodyY, legY);
                } else if (Math.abs(this.vx) > 0) {
                    this.drawWalkPose(centerX, headY, bodyY, legY);
                } else {
                    this.drawIdlePose(centerX, headY, bodyY, legY);
                }
                
                // Zenã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼æº–å‚™çŠ¶æ…‹ã®è¡¨ç¤º
                if (this.charType === 'zen' && this.counterReady && this.isBlocking) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.strokeStyle = '#ff4';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, bodyY, 25, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                // Universalã®å›é¿ä¸­ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                if (this.charType === 'universal' && this.invincible > 0 && this.evadeFrames > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = '#4f4';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, bodyY, 30, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.restore();
            }
            
            drawIdlePose(cx, headY, bodyY, legY) {
                const breathe = Math.sin(this.animFrame) * 2;
                
                // è…•
                ctx.beginPath();
                ctx.moveTo(cx, bodyY - 5);
                ctx.lineTo(cx - this.facing * 15, bodyY + 10 + breathe);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(cx, bodyY - 5);
                ctx.lineTo(cx + this.facing * 15, bodyY + 10 + breathe);
                ctx.stroke();
                
                // è„š
                ctx.beginPath();
                ctx.moveTo(cx, bodyY + 15);
                ctx.lineTo(cx - 10, legY);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(cx, bodyY + 15);
                ctx.lineTo(cx + 10, legY);
                ctx.stroke();
            }
            
            drawWalkPose(cx, headY, bodyY, legY) {
                const walk = Math.sin(this.animFrame * 3) * 15;
                
                // è…•
                ctx.beginPath();
                ctx.moveTo(cx, bodyY - 5);
                ctx.lineTo(cx - this.facing * 10, bodyY + 15 + walk);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(cx, bodyY - 5);
                ctx.lineTo(cx + this.facing * 10, bodyY + 15 - walk);
                ctx.stroke();
                
                // è„š
                ctx.beginPath();
                ctx.moveTo(cx, bodyY + 15);
                ctx.lineTo(cx - 10, legY - Math.abs(walk));
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(cx, bodyY + 15);
                ctx.lineTo(cx + 10, legY - Math.abs(-walk));
                ctx.stroke();
            }
            
            drawJumpPose(cx, headY, bodyY, legY) {
                // è…•
                ctx.beginPath();
                ctx.moveTo(cx, bodyY - 5);
                ctx.lineTo(cx - this.facing * 20, bodyY - 10);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(cx, bodyY - 5);
                ctx.lineTo(cx + this.facing * 20, bodyY - 10);
                ctx.stroke();
                
                // è„š
                ctx.beginPath();
                ctx.moveTo(cx, bodyY + 15);
                ctx.lineTo(cx - 15, legY - 10);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(cx, bodyY + 15);
                ctx.lineTo(cx + 15, legY - 10);
                ctx.stroke();
            }
            
            drawBlockPose(cx, headY, bodyY, legY) {
                // è…•ï¼ˆé˜²å¾¡ï¼‰
                ctx.beginPath();
                ctx.moveTo(cx, bodyY - 5);
                ctx.lineTo(cx - this.facing * 20, headY + 20);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(cx, bodyY - 5);
                ctx.lineTo(cx + this.facing * 20, headY + 20);
                ctx.stroke();
                
                // è„š
                ctx.beginPath();
                ctx.moveTo(cx, bodyY + 15);
                ctx.lineTo(cx - 12, legY);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(cx, bodyY + 15);
                ctx.lineTo(cx + 12, legY);
                ctx.stroke();
            }
            
            drawAttackPose(cx, headY, bodyY, legY) {
                const progress = this.attackFrame / (this.attacks[this.attackType].startup + this.attacks[this.attackType].recovery);
                const extend = Math.sin(progress * Math.PI) * 30;
                
                if (this.attackType === 'punch' || this.attackType === 'special') {
                    // ãƒ‘ãƒ³ãƒ
                    ctx.beginPath();
                    ctx.moveTo(cx, bodyY - 5);
                    ctx.lineTo(cx + this.facing * (25 + extend), bodyY);
                    ctx.stroke();
                    
                    // ã‚‚ã†ç‰‡æ–¹ã®è…•
                    ctx.beginPath();
                    ctx.moveTo(cx, bodyY - 5);
                    ctx.lineTo(cx - this.facing * 10, bodyY + 10);
                    ctx.stroke();
                    
                    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    if (this.attackFrame === this.attacks[this.attackType].startup) {
                        const effectX = cx + this.facing * (25 + extend);
                        for (let i = 0; i < 3; i++) {
                            ctx.fillStyle = this.color;
                            ctx.globalAlpha = 0.5;
                            ctx.beginPath();
                            ctx.arc(effectX + this.facing * i * 10, bodyY, 8 - i * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                } else {
                    // ã‚­ãƒƒã‚¯
                    ctx.beginPath();
                    ctx.moveTo(cx, bodyY + 15);
                    ctx.lineTo(cx + this.facing * (20 + extend), bodyY + 10);
                    ctx.stroke();
                    
                    // ã‚‚ã†ç‰‡æ–¹ã®è„š
                    ctx.beginPath();
                    ctx.moveTo(cx, bodyY + 15);
                    ctx.lineTo(cx - this.facing * 5, legY);
                    ctx.stroke();
                    
                    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    if (this.attackFrame === this.attacks[this.attackType].startup) {
                        const effectX = cx + this.facing * (20 + extend);
                        for (let i = 0; i < 3; i++) {
                            ctx.fillStyle = this.color;
                            ctx.globalAlpha = 0.5;
                            ctx.beginPath();
                            ctx.arc(effectX + this.facing * i * 10, bodyY + 10, 8 - i * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                // è…•ï¼ˆæ”»æ’ƒã—ã¦ã„ãªã„æ–¹ï¼‰
                ctx.beginPath();
                ctx.moveTo(cx, bodyY - 5);
                ctx.lineTo(cx - this.facing * 15, bodyY + 5);
                ctx.stroke();
                
                // è„šï¼ˆé€šå¸¸ï¼‰
                ctx.beginPath();
                ctx.moveTo(cx, bodyY + 15);
                ctx.lineTo(cx - 10, legY);
                ctx.stroke();
            }
            
            drawSpecialMoveAnimation(cx, headY, bodyY, legY, progress, extend) {
                // å¿…æ®ºæŠ€ã”ã¨ã®å›ºæœ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                switch(this.specialMoveName) {
                    case 'ultimate_impact': // Ash
                        // çªé€²ã™ã‚‹ãƒ‘ãƒ³ãƒ
                        const dash = progress < 0.3 ? progress * 100 : (1 - progress) * 50;
                        this.x += this.facing * dash * 0.5;
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx + this.facing * (40 + extend * 1.5), bodyY);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx - this.facing * 5, bodyY + 5);
                        ctx.stroke();
                        break;
                        
                    case 'middle_kick': // Cyber-K
                        // æ¨ªæ–¹å‘ã®åºƒç¯„å›²ã‚­ãƒƒã‚¯
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY + 15);
                        ctx.lineTo(cx + this.facing * (30 + extend), bodyY);
                        ctx.lineTo(cx + this.facing * (35 + extend), bodyY - 5);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY + 15);
                        ctx.lineTo(cx - this.facing * 10, legY);
                        ctx.stroke();
                        break;
                        
                    case 'granite_press': // Granite
                        // çªé€²æŠ€
                        const graniteDash = progress < 0.4 ? progress * 120 : (1 - progress) * 30;
                        this.x += this.facing * graniteDash * 0.6;
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx + this.facing * (35 + extend), bodyY + 10);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx + this.facing * 20, bodyY + 15);
                        ctx.stroke();
                        break;
                        
                    case 'mujihi_hoyo': // Mystia
                        // ä¸Šæ®µã‚­ãƒƒã‚¯ï¼ˆè†è¹´ã‚Šï¼‰
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY + 15);
                        ctx.lineTo(cx + this.facing * 15, bodyY - 10);
                        ctx.lineTo(cx + this.facing * (20 + extend), bodyY - 15);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY + 15);
                        ctx.lineTo(cx - this.facing * 5, legY);
                        ctx.stroke();
                        break;
                        
                    case 'kuusemi_gaashi': // Zen
                        // åæ’ƒå‹ï¼ˆç´ æ—©ã„çªãï¼‰
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx + this.facing * (30 + extend * 1.2), bodyY - 5);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx - this.facing * 15, bodyY);
                        ctx.stroke();
                        break;
                        
                    case 'emergency_step': // Universal
                        // å›é¿ã‹ã‚‰ã®åæ’ƒ
                        const evadeStep = progress < 0.2 ? -30 : 20;
                        this.x += this.facing * evadeStep * 0.3;
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx + this.facing * (25 + extend), bodyY);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx - this.facing * 10, bodyY + 5);
                        ctx.stroke();
                        break;
                }
                
                // è„š
                ctx.beginPath();
                ctx.moveTo(cx, bodyY + 15);
                ctx.lineTo(cx - 10, legY);
                ctx.stroke();
                
                // å¿…æ®ºæŠ€åè¡¨ç¤º
                if (this.specialMoveNameFrames > 0 && this.attackFrame < 10) {
                    ctx.save();
                    ctx.translate(cx, headY - 40);
                    ctx.globalAlpha = Math.min(1, this.specialMoveNameFrames / 20);
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 4;
                    ctx.font = 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const moveNames = {
                        'ultimate_impact': 'Ultimate Impact!',
                        'middle_kick': 'Middle Kick!',
                        'granite_press': 'Granite Press!',
                        'mujihi_hoyo': 'Mujihi na Hoyo!',
                        'kuusemi_gaashi': 'Kuusemi-gaashi!',
                        'emergency_step': 'Emergency Step!'
                    };
                    const moveName = moveNames[this.specialMoveName] || 'Special Move!';
                    ctx.strokeText(moveName, 0, 0);
                    ctx.fillText(moveName, 0, 0);
                    ctx.restore();
                }
                
                // å¿…æ®ºæŠ€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                if (this.attackFrame === this.attacks[this.attackType].startup) {
                    const effectX = cx + this.facing * (30 + extend);
                    for (let i = 0; i < 5; i++) {
                        ctx.fillStyle = this.color;
                        ctx.globalAlpha = 0.6;
                        ctx.beginPath();
                        ctx.arc(effectX + this.facing * i * 15, bodyY, 12 - i * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            drawSpecialAbilityPose(cx, headY, bodyY, legY) {
                switch (this.specialAbilityType) {
                    case 'throw': // Graniteã®æŠ•ã’æŠ€
                        const throwProgress = this.specialAbilityFrame / 40;
                        // æŠ•ã’ã‚‹ãƒãƒ¼ã‚º
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx + this.facing * 25, bodyY + 5 + Math.sin(throwProgress * Math.PI) * 10);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx - this.facing * 15, bodyY + 10);
                        ctx.stroke();
                        
                        // è„š
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY + 15);
                        ctx.lineTo(cx - 12, legY);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY + 15);
                        ctx.lineTo(cx + 12, legY);
                        ctx.stroke();
                        break;
                        
                    case 'evade': // Universalã®ç·Šæ€¥å›é¿
                        // å¾Œã‚ã«è·³ã¶ãƒãƒ¼ã‚º
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx + this.facing * 20, bodyY - 10);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx - this.facing * 20, bodyY - 10);
                        ctx.stroke();
                        
                        // è„šã‚’æ›²ã’ãŸãƒãƒ¼ã‚º
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY + 15);
                        ctx.lineTo(cx - 15, legY - 15);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY + 15);
                        ctx.lineTo(cx + 15, legY - 15);
                        ctx.stroke();
                        break;
                        
                    case 'hug': // Mystiaã®æŠ±æ“æŠ€
                        const hugProgress = this.specialAbilityFrame / 30;
                        // æŠ±æ“ã™ã‚‹ãƒãƒ¼ã‚º
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx + this.facing * (20 + Math.sin(hugProgress * Math.PI) * 15), bodyY);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY - 5);
                        ctx.lineTo(cx - this.facing * (20 + Math.sin(hugProgress * Math.PI) * 15), bodyY);
                        ctx.stroke();
                        
                        // è„š
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY + 15);
                        ctx.lineTo(cx - 10, legY);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(cx, bodyY + 15);
                        ctx.lineTo(cx + 10, legY);
                        ctx.stroke();
                        break;
                }
            }
        }
        
        // ç¾åœ¨ã®èƒŒæ™¯è¨­å®šï¼ˆCPUé¸æŠã«å¿œã˜ã¦å¤‰æ›´ï¼‰
        let currentBackground = null;
        
        // éŸ³å£°èª­ã¿ä¸Šã’é–¢æ•°
        function speakRound(roundNumber) {
            const roundNames = ['', 'ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ¯ãƒ³', 'ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ„ãƒ¼', 'ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¹ãƒªãƒ¼'];
            if (roundNumber >= 1 && roundNumber <= 3) {
                const utterance = new SpeechSynthesisUtterance(roundNames[roundNumber]);
                utterance.lang = 'ja-JP';
                utterance.rate = 0.9; // å°‘ã—ã‚†ã£ãã‚Š
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                try {
                    window.speechSynthesis.speak(utterance);
                } catch (e) {
                    // éŸ³å£°åˆæˆãŒä½¿ãˆãªã„å ´åˆã¯ç„¡è¦–
                    console.log('éŸ³å£°åˆæˆãŒä½¿ç”¨ã§ãã¾ã›ã‚“');
                }
            }
        }
        
        function initGame() {
            // ãƒ©ã‚¦ãƒ³ãƒ‰åˆ¶ã®åˆæœŸåŒ–
            currentRound = 1;
            player1Wins = 0;
            player2Wins = 0;
            roundStarting = true;
            roundStartFrames = 0;
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆæœŸåŒ–
            player1 = new Player(
                canvas.width * 0.25,
                canvas.height - 180,
                { left: 'ArrowLeft', right: 'ArrowRight', up: 'ArrowUp', down: 'ArrowDown', punch: 'KeyM', kick: 'KeyN', special: 'KeyB' },
                selectedP1,
                1
            );
            
            player2 = new Player(
                canvas.width * 0.75,
                canvas.height - 180,
                { left: 'KeyA', right: 'KeyD', up: 'KeyW', down: 'KeyS', punch: 'KeyG', kick: 'KeyH', special: 'KeyJ' },
                selectedP2,
                -1,
                true // CPUãƒ¢ãƒ¼ãƒ‰
            );
            
            // èƒŒæ™¯è¨­å®šï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1å´ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«å¿œã˜ã¦ï¼‰
            currentBackground = characterData[selectedP1].background;
            
            // UIæ›´æ–°
            document.getElementById('player1Name').textContent = player1.name;
            document.getElementById('player2Name').textContent = player2.name + ' (CPU)';
            document.getElementById('player1Wins').textContent = player1Wins;
            document.getElementById('player2Wins').textContent = player2Wins;
            document.getElementById('roundInfo').style.display = 'block';
            
            // ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            roundStartMessage = `ROUND ${currentRound}`;
            document.getElementById('roundText').textContent = roundStartMessage;
            
            // ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹éŸ³å£°
            speakRound(currentRound);
            
            gameRunning = true;
            gameTime = 99;
            lastTime = Date.now();
            
            // BGMé–‹å§‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå¾Œã«éŸ³å£°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å¾©å…ƒï¼‰
            try {
                initAudioContexts();
                resumeAudioContexts();
                playBGM();
            } catch (e) {
                // éŸ³å£°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒä½¿ãˆãªã„å ´åˆã¯ç„¡è¦–
                console.warn('éŸ³å£°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', e);
            }
            
            gameLoop();
        }
        
        function startNextRound() {
            // æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’é–‹å§‹
            currentRound++;
            
            // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯ï¼ˆå…ˆã«2å‹ã—ãŸæ–¹ãŒå‹åˆ©ï¼‰
            if (player1Wins >= 2 || player2Wins >= 2) {
                const winner = player1Wins >= 2 ? player1.name : player2.name;
                endGame(winner + ' ã®å‹åˆ©ï¼');
                return;
            }
            
            // æœ€å¤§ãƒ©ã‚¦ãƒ³ãƒ‰æ•°ã‚’è¶…ãˆãŸå ´åˆ
            if (currentRound > maxRounds) {
                // å‹åˆ©æ•°ãŒå¤šã„æ–¹ãŒå‹åˆ©
                if (player1Wins > player2Wins) {
                    endGame(player1.name + ' ã®å‹åˆ©ï¼');
                } else if (player2Wins > player1Wins) {
                    endGame(player2.name + ' ã®å‹åˆ©ï¼');
                } else {
                    endGame('å¼•ãåˆ†ã‘ï¼');
                }
                return;
            }
            
            // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¯ãƒªã‚¢
            particles.length = 0;
            damageNumbers.length = 0;
            criticalTexts.length = 0;
            cameraShake.frames = 0;
            cameraShake.x = 0;
            cameraShake.y = 0;
            slowMotionActive = false;
            
            // ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹å‡¦ç†
            roundStarting = true;
            roundStartFrames = 0;
            roundStartMessage = `ROUND ${currentRound}`;
            document.getElementById('roundText').textContent = roundStartMessage;
            document.getElementById('roundInfo').style.display = 'block';
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
            player1.health = 100;
            player1.guardGauge = 100;
            player1.guardCrushed = false;
            player1.stunned = 0;
            player1.comboCount = 0;
            player1.comboTimer = 0;
            player1.x = canvas.width * 0.25;
            player1.y = canvas.height - 180;
            player1.vx = 0;
            player1.vy = 0;
            player1.isAttacking = false;
            player1.specialAbilityActive = false;
            player1.superMoveActive = false;
            player1.superGauge = 0;
            
            player2.health = 100;
            player2.guardGauge = 100;
            player2.guardCrushed = false;
            player2.stunned = 0;
            player2.comboCount = 0;
            player2.comboTimer = 0;
            player2.x = canvas.width * 0.75;
            player2.y = canvas.height - 180;
            player2.vx = 0;
            player2.vy = 0;
            player2.isAttacking = false;
            player2.specialAbilityActive = false;
            player2.superMoveActive = false;
            player2.superGauge = 0;
            
            // ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
            gameTime = 99;
            lastTime = Date.now();
            
            // ã‚²ãƒ¼ãƒ å†é–‹
            gameRunning = true;
            
            // ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹éŸ³å£°
            speakRound(currentRound);
            
            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’å†é–‹
            gameLoop();
        }
        
        function gameLoop() {
            if (!gameRunning) return;
            
            // ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹æ¼”å‡º
            if (roundStarting) {
                roundStartFrames++;
                if (roundStartFrames >= 120) { // 2ç§’é–“è¡¨ç¤º
                    roundStarting = false;
                    document.getElementById('roundInfo').style.display = 'none';
                }
                // ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹ä¸­ã‚‚æç”»ã¯ç¶šè¡Œ
                draw();
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
            const now = Date.now();
            if (now - lastTime >= 1000) {
                gameTime--;
                lastTime = now;
                document.getElementById('timer').textContent = gameTime;
                
                if (gameTime <= 0) {
                    // ã‚¿ã‚¤ãƒ ã‚¢ãƒƒãƒ—æ™‚ã®åˆ¤å®šï¼ˆä½“åŠ›ãŒå¤šã„æ–¹ãŒå‹åˆ©ï¼‰
                    if (player1.health > player2.health) {
                        player1Wins++;
                        document.getElementById('player1Wins').textContent = player1Wins;
                        setTimeout(() => startNextRound(), 2000);
                    } else if (player2.health > player1.health) {
                        player2Wins++;
                        document.getElementById('player2Wins').textContent = player2Wins;
                        setTimeout(() => startNextRound(), 2000);
                    } else {
                        // å¼•ãåˆ†ã‘ã®å ´åˆã¯æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã¸
                        setTimeout(() => startNextRound(), 2000);
                    }
                    return;
                }
            }
            
            // ã‚¹ãƒ­ãƒ¼ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            if (slowMotionActive) {
                slowMotionFrames--;
                if (slowMotionFrames <= 0) {
                    slowMotionActive = false;
                    slowMotionSpeed = 1.0;
                }
            }
            
            // æ›´æ–°å‡¦ç†ï¼ˆã‚¹ãƒ­ãƒ¼ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³é©ç”¨ï¼‰
            if (!slowMotionActive || slowMotionFrames % Math.round(1 / slowMotionSpeed) === 0) {
            player1.update();
            player2.update();
            }
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å­—æ›´æ–°
            for (let i = damageNumbers.length - 1; i >= 0; i--) {
                damageNumbers[i].update();
                if (damageNumbers[i].life <= 0) {
                    damageNumbers.splice(i, 1);
                }
            }
            
            // ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
            for (let i = criticalTexts.length - 1; i >= 0; i--) {
                criticalTexts[i].update();
                if (criticalTexts[i].life <= 0) {
                    criticalTexts.splice(i, 1);
                }
            }
            
            // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯æ›´æ–°
            if (cameraShake.frames > 0) {
                cameraShake.frames--;
                const shake = cameraShake.intensity * (cameraShake.frames / 20);
                cameraShake.x = (Math.random() - 0.5) * shake;
                cameraShake.y = (Math.random() - 0.5) * shake;
            } else {
                cameraShake.x = 0;
                cameraShake.y = 0;
            }
            
            // ä½“åŠ›ãƒã‚§ãƒƒã‚¯ï¼ˆKOæ¼”å‡ºï¼‰
            if (player1.health <= 0) {
                player1.health = 0; // ç¢ºå®Ÿã«0ã«ã™ã‚‹
                if (gameRunning) { // ä¸€åº¦ã ã‘å®Ÿè¡Œ
                    stopBGM();
                    playKOSound();
                    startSlowMotion(0.2, 60);
                    shakeCamera(20, 30);
                    createKOEffect(player1);
                    
                    // ãƒ©ã‚¦ãƒ³ãƒ‰å‹åˆ©å‡¦ç†
                    player2Wins++;
                    document.getElementById('player2Wins').textContent = player2Wins;
                    
                    setTimeout(() => {
                        playVictorySound();
                        // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯
                        if (player2Wins >= 2) {
                endGame(player2.name + ' ã®å‹åˆ©ï¼');
                            gameRunning = false;
                        } else {
                            // æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã¸
                            startNextRound();
                        }
                    }, 2000);
                    gameRunning = false;
                }
                return;
            }
            if (player2.health <= 0) {
                player2.health = 0; // ç¢ºå®Ÿã«0ã«ã™ã‚‹
                if (gameRunning) { // ä¸€åº¦ã ã‘å®Ÿè¡Œ
                    stopBGM();
                    playKOSound();
                    startSlowMotion(0.2, 60);
                    shakeCamera(20, 30);
                    createKOEffect(player2);
                    
                    // ãƒ©ã‚¦ãƒ³ãƒ‰å‹åˆ©å‡¦ç†
                    player1Wins++;
                    document.getElementById('player1Wins').textContent = player1Wins;
                    
                    setTimeout(() => {
                        playVictorySound();
                        // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯
                        if (player1Wins >= 2) {
                endGame(player1.name + ' ã®å‹åˆ©ï¼');
                            gameRunning = false;
                        } else {
                            // æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã¸
                            startNextRound();
                        }
                    }, 2000);
                    gameRunning = false;
                }
                return;
            }
            
            // æç”»
            draw();
            
            // UIæ›´æ–°
            document.getElementById('player1Health').style.width = player1.health + '%';
            document.getElementById('player2Health').style.width = player2.health + '%';
            
            // ã‚¬ãƒ¼ãƒ‰ã‚²ãƒ¼ã‚¸æ›´æ–°
            const p1GuardPercent = Math.max(0, (player1.guardGauge / player1.maxGuardGauge) * 100);
            const p2GuardPercent = Math.max(0, (player2.guardGauge / player2.maxGuardGauge) * 100);
            document.getElementById('player1Guard').style.width = p1GuardPercent + '%';
            document.getElementById('player2Guard').style.width = p2GuardPercent + '%';
            
            // è¶…å¿…æ®ºæŠ€ã‚²ãƒ¼ã‚¸æ›´æ–°
            updateSuperGauge('player1SuperGauge', player1.superGauge);
            updateSuperGauge('player2SuperGauge', player2.superGauge);
            
            // ã‚³ãƒ³ãƒœè¡¨ç¤ºæ›´æ–°
            const p1ComboEl = document.getElementById('player1Combo');
            const p2ComboEl = document.getElementById('player2Combo');
            
            if (player1.comboCount > 1) {
                p1ComboEl.textContent = player1.comboCount + ' HIT COMBO!';
                p1ComboEl.classList.add('active');
            } else {
                p1ComboEl.classList.remove('active');
            }
            
            if (player2.comboCount > 1) {
                p2ComboEl.textContent = player2.comboCount + ' HIT COMBO!';
                p2ComboEl.classList.add('active');
            } else {
                p2ComboEl.classList.remove('active');
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function updateSuperGauge(elementId, gauge) {
            const container = document.getElementById(elementId);
            if (!container) return;
            
            const segments = container.querySelectorAll('.super-gauge-segment');
            const gaugeCount = Math.floor(gauge / 100); // ã‚²ãƒ¼ã‚¸æ•°ï¼ˆ0-3ï¼‰
            
            segments.forEach((segment, index) => {
                if (index < gaugeCount) {
                    segment.classList.remove('empty');
                } else {
                    segment.classList.add('empty');
                }
            });
        }
        
        function createKOEffect(player) {
            // KOã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼šçˆ†ç™ºçš„ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            for (let i = 0; i < 100; i++) {
                particles.push(new Particle(
                    player.x + player.width / 2,
                    player.y + player.height / 2,
                    '#f00'
                ));
            }
            // KOãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
            criticalTexts.push(new CriticalText(
                canvas.width / 2,
                canvas.height / 2 - 50,
                'K.O.!'
            ));
        }
        
        function drawBackground() {
            if (!currentBackground) return;
            
            const bg = currentBackground;
            const groundY = canvas.height - 100;
            
            // ç©ºã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆç”»é¢å…¨ä½“ã‚’ã‚«ãƒãƒ¼ï¼‰
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.7);
            bg.sky.forEach((color, index) => {
                skyGradient.addColorStop(index / (bg.sky.length - 1), color);
            });
            ctx.fillStyle = skyGradient;
            // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯ã‚’è€ƒæ…®ã—ã¦ã€ã‚ˆã‚Šåºƒã„ç¯„å›²ã‚’æç”»
            ctx.fillRect(-Math.abs(cameraShake.x) - 50, -Math.abs(cameraShake.y) - 50, 
                         canvas.width + Math.abs(cameraShake.x) * 2 + 100, 
                         canvas.height * 0.7 + Math.abs(cameraShake.y) + 100);
            
            // å»ºç‰©ã‚„èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆãƒ†ãƒ¼ãƒã«å¿œã˜ã¦ï¼‰
            switch(bg.theme) {
                case 'futuristic_city':
                    // æœªæ¥éƒ½å¸‚ã®å»ºç‰©
                    for (let i = 0; i < 5; i++) {
                        const x = (i * canvas.width / 5) - (cameraShake.x * 0.1);
                        const height = 100 + Math.sin(i) * 40;
                        ctx.fillStyle = bg.buildings[i % bg.buildings.length];
                        ctx.fillRect(x, canvas.height * 0.7 - height, canvas.width / 6, height);
                        
                        // çª“ï¼ˆå›ºå®šä½ç½®ã§æç”»ï¼‰
                        ctx.fillStyle = 'rgba(255, 255, 100, 0.8)';
                        for (let w = 0; w < 3; w++) {
                            for (let h = 0; h < Math.floor(height / 30); h++) {
                                const seed = (i * 100) + (w * 10) + h;
                                if (seed % 10 > 3) { // å›ºå®šã®æ¡ä»¶ã§è¡¨ç¤º
                                    ctx.fillRect(x + 10 + w * 20, canvas.height * 0.7 - height + 10 + h * 30, 8, 10);
                                }
                            }
                        }
                    }
                    break;
                    
                case 'cyberpunk':
                    // ã‚µã‚¤ãƒãƒ¼ãƒ‘ãƒ³ã‚¯é¢¨ã®å»ºç‰©
                    for (let i = 0; i < 4; i++) {
                        const x = (i * canvas.width / 4) - (cameraShake.x * 0.15);
                        const height = 120 + Math.sin(i * 2) * 50;
                        ctx.fillStyle = bg.buildings[i % bg.buildings.length];
                        ctx.fillRect(x, canvas.height * 0.7 - height, canvas.width / 5, height);
                        
                        // ãƒã‚ªãƒ³ãƒ©ã‚¤ãƒ³
                        ctx.strokeStyle = bg.buildings[0];
            ctx.lineWidth = 2;
                ctx.beginPath();
                        ctx.moveTo(x, canvas.height * 0.7 - height);
                        ctx.lineTo(x + canvas.width / 5, canvas.height * 0.7 - height);
                ctx.stroke();
            }
                    break;
                    
                case 'rocky_mountain':
                    // å²©å±±
                    ctx.fillStyle = bg.buildings[0];
                    const mountainPoints = [];
                    for (let i = 0; i <= 10; i++) {
                        const x = (i * canvas.width / 10) - cameraShake.x * 0.05;
                        // å›ºå®šã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ä½¿ç”¨ï¼ˆMath.random()ã®ä»£ã‚ã‚Šã«å›ºå®šå€¤ï¼‰
                        const fixedOffset = (i % 3) * 7 - 7; // -7, 0, 7ã‚’ç¹°ã‚Šè¿”ã™
                        const y = canvas.height * 0.7 - 80 - Math.sin(i * 0.5) * 40 + fixedOffset;
                        mountainPoints.push({x, y});
                    }
                    ctx.beginPath();
                    ctx.moveTo(mountainPoints[0].x, canvas.height * 0.7);
                    mountainPoints.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.lineTo(mountainPoints[mountainPoints.length - 1].x, canvas.height * 0.7);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'magical_forest':
                    // é­”æ³•ã®æ£®ã®æœ¨
                    for (let i = 0; i < 6; i++) {
                        const x = (i * canvas.width / 6) - cameraShake.x * 0.08;
                        const trunkHeight = 60 + Math.sin(i) * 20;
                        const trunkWidth = 15;
                        
                        // å¹¹
                        ctx.fillStyle = bg.buildings[2];
                        ctx.fillRect(x - trunkWidth/2, canvas.height * 0.7 - trunkHeight, trunkWidth, trunkHeight);
                        
                        // è‘‰ï¼ˆä¸¸ï¼‰
                        ctx.fillStyle = bg.buildings[1];
                        ctx.beginPath();
                        ctx.arc(x, canvas.height * 0.7 - trunkHeight, 30 + Math.sin(i * 2) * 10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // å…‰ã‚‹åŠ¹æœï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ åŒã˜ä½ç½®ã«è¡¨ç¤ºã™ã‚‹ãŸã‚ã€å›ºå®šå€¤ã‚’ä½¿ç”¨ï¼‰
                        const seed = i * 7; // å›ºå®šã‚·ãƒ¼ãƒ‰å€¤
                        if ((seed % 10) > 3) {
                            ctx.save();
                            ctx.fillStyle = bg.buildings[0];
                            ctx.globalAlpha = 0.5;
                            const lightX = x + (seed % 20) - 10;
                            const lightY = canvas.height * 0.7 - trunkHeight - 20 + ((seed * 3) % 20) - 10;
                            ctx.beginPath();
                            ctx.arc(lightX, lightY, 3, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                    break;
                    
                case 'peaceful_temple':
                    // å¯ºé™¢é¢¨ã®å»ºç‰©
                    for (let i = 0; i < 3; i++) {
                        const x = (i * canvas.width / 3) - cameraShake.x * 0.1;
                        const height = 90;
                        ctx.fillStyle = bg.buildings[i % bg.buildings.length];
                        ctx.fillRect(x, canvas.height * 0.7 - height, canvas.width / 4, height);
                        
                        // å±‹æ ¹ï¼ˆä¸‰è§’ï¼‰
                        ctx.beginPath();
                        ctx.moveTo(x - 20, canvas.height * 0.7 - height);
                        ctx.lineTo(x + canvas.width / 8, canvas.height * 0.7 - height - 30);
                        ctx.lineTo(x + canvas.width / 4 + 20, canvas.height * 0.7 - height);
                        ctx.closePath();
                        ctx.fillStyle = bg.buildings[1];
                        ctx.fill();
                    }
                    break;
                    
                case 'cosmic_arena':
                    // å®‡å®™ã‚¢ãƒªãƒ¼ãƒŠï¼ˆæ˜Ÿã¨æ˜Ÿé›²ï¼‰- å›ºå®šä½ç½®ã§æç”»
                    for (let i = 0; i < 30; i++) {
                        // å›ºå®šã®ä½ç½®è¨ˆç®—ï¼ˆç–‘ä¼¼ä¹±æ•°ï¼‰
                        const seedX = (i * 137.5) % canvas.width; // é»„é‡‘æ¯”ã‚’ä½¿ã£ãŸåˆ†å¸ƒ
                        const seedY = (i * 97.3) % (canvas.height * 0.7);
                        const x = seedX - cameraShake.x * 0.2;
                        const y = seedY;
                        const alpha = 0.3 + ((i * 0.1) % 0.7);
                        const size = 1 + ((i % 3) * 0.5);
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // æ˜Ÿé›²ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    ctx.save();
                    ctx.fillStyle = bg.buildings[0];
                    ctx.globalAlpha = 0.3;
                    for (let i = 0; i < 3; i++) {
                        const x = (i * canvas.width / 3) - cameraShake.x * 0.15;
                        ctx.beginPath();
                        ctx.arc(x, canvas.height * 0.3, 80 + Math.sin(i) * 30, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                    break;
            }
            
            // åœ°é¢ï¼ˆç”»é¢å…¨ä½“ã‚’å¡—ã‚Šã¤ã¶ã—ã¦ã€åœ°é¢ã®ä½ç½®ã‚’æ­£ç¢ºã«æç”»ï¼‰
            ctx.fillStyle = bg.ground;
            // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯ã‚’è€ƒæ…®ã—ã¦åºƒã‚ã«æç”»
            const groundWidth = canvas.width + Math.abs(cameraShake.x) * 2 + 100;
            const groundHeight = canvas.height - groundY + Math.abs(cameraShake.y) + 50;
            ctx.fillRect(-Math.abs(cameraShake.x) - 50, groundY, groundWidth, groundHeight);
            
            // åœ°é¢ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼ˆãƒ†ãƒ¼ãƒã«å¿œã˜ã¦ï¼‰
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const startX = -Math.abs(cameraShake.x) - 50;
            for (let i = 0; i < groundWidth; i += 30) {
                ctx.beginPath();
                ctx.moveTo(startX + i, groundY);
                ctx.lineTo(startX + i + 20, groundY);
                ctx.stroke();
            }
        }
        
        function draw() {
            // ç”»é¢ã‚’ã‚¯ãƒªã‚¢ï¼ˆæ®‹åƒã‚’é˜²ãï¼‰
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            
            // ç”»é¢ã‚·ã‚§ã‚¤ã‚¯é©ç”¨
            ctx.translate(cameraShake.x, cameraShake.y);
            
            // èƒŒæ™¯æç”»
            drawBackground();
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            particles.forEach(p => p.draw());
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
            player1.draw();
            player2.draw();
            
            // ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å­—
            damageNumbers.forEach(dn => dn.draw());
            
            // ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ†ã‚­ã‚¹ãƒˆ
            criticalTexts.forEach(ct => ct.draw());
            
            ctx.restore();
            
            // ç”»é¢ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼ˆè¶…å¿…æ®ºæŠ€ç™ºå‹•æ™‚ï¼‰
            if (screenFlash.active) {
                ctx.save();
                const alpha = screenFlash.frames / 10;
                ctx.fillStyle = screenFlash.color;
                ctx.globalAlpha = alpha * 0.5;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
                
                screenFlash.frames--;
                if (screenFlash.frames <= 0) {
                    screenFlash.active = false;
                }
            }
            
            // ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹æ¼”å‡ºã®æç”»
            if (roundStarting) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 4;
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const scale = Math.min(1.0, roundStartFrames / 30);
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(scale, scale);
                ctx.strokeText(roundStartMessage, 0, -20);
                ctx.fillText(roundStartMessage, 0, -20);
                ctx.restore();
                
                ctx.restore();
            }
        }
        
        function endGame(message) {
            gameRunning = false;
            document.getElementById('winnerText').textContent = message;
            document.getElementById('winMethod').textContent = 
                gameTime <= 0 ? 'ã‚¿ã‚¤ãƒ ã‚¢ãƒƒãƒ—' : 'K.O.';
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // ãƒ¢ãƒã‚¤ãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        const mobileControls = {
            p1Up: 'ArrowUp',
            p1Down: 'ArrowDown',
            p1Left: 'ArrowLeft',
            p1Right: 'ArrowRight',
            p1Punch: 'KeyM',
            p1Kick: 'KeyN',
            p1Special: 'KeyB'
        };
        
        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆiOSå¯¾å¿œå¼·åŒ–ï¼‰
        function handleTouchStart(e, key) {
            e.preventDefault();
            e.stopPropagation();
            keys[key] = true;
            
            // è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
            const target = e.currentTarget;
            target.classList.add('touching');
        }
        
        function handleTouchEnd(e, key) {
            e.preventDefault();
            e.stopPropagation();
            keys[key] = false;
            
            // è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è§£é™¤
            const target = e.currentTarget;
            target.classList.remove('touching');
        }
        
        function handleTouchCancel(e, key) {
            e.preventDefault();
            e.stopPropagation();
            keys[key] = false;
            
            // è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è§£é™¤
            const target = e.currentTarget;
            target.classList.remove('touching');
        }
        
        // iOSå‘ã‘ã®ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‚‚ã‚µãƒãƒ¼ãƒˆï¼ˆã‚¿ãƒƒãƒã¨ãƒã‚¦ã‚¹ã®ä¸¡æ–¹ã«å¯¾å¿œï¼‰
        function handleMouseDown(e, key) {
            e.preventDefault();
            keys[key] = true;
            e.currentTarget.classList.add('touching');
        }
        
        function handleMouseUp(e, key) {
            e.preventDefault();
            keys[key] = false;
            e.currentTarget.classList.remove('touching');
        }
        
        function handleMouseLeave(e, key) {
            keys[key] = false;
            e.currentTarget.classList.remove('touching');
        }
        
        // ãƒ¢ãƒã‚¤ãƒ«ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã®åˆæœŸåŒ–
        Object.keys(mobileControls).forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) {
                const key = mobileControls[btnId];
                
                // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆï¼ˆiOSå¯¾å¿œï¼‰
                btn.addEventListener('touchstart', (e) => handleTouchStart(e, key), { passive: false });
                btn.addEventListener('touchend', (e) => handleTouchEnd(e, key), { passive: false });
                btn.addEventListener('touchcancel', (e) => handleTouchCancel(e, key), { passive: false });
                
                // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—å¯¾å¿œï¼‰
                btn.addEventListener('mousedown', (e) => handleMouseDown(e, key));
                btn.addEventListener('mouseup', (e) => handleMouseUp(e, key));
                btn.addEventListener('mouseleave', (e) => handleMouseLeave(e, key));
            }
        });
        
        // ç”»é¢å¤–ã‚¿ãƒƒãƒæ™‚ã®å‡¦ç†ï¼ˆiOSå¯¾å¿œï¼‰
        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas || e.target.closest('.mobile-controls')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchstart', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
